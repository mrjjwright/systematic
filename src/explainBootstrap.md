Understood! I will investigate whether it is possible to inject third-party imports into the core of VS Code contributions, either from local node modules or directly from the internet. This will involve analyzing VS Code's Electron sandboxing, dynamic module resolution, and security mechanisms that might prevent or allow such behavior.

I’ll update you with the findings soon.

# Injecting Third-Party Modules in VS Code Core and Extensions

Visual Studio Code’s architecture is designed to be extensible but also mindful of security. Here’s what the research shows about loading third-party modules into VS Code’s core or extension contributions:

## How VS Code Loads Modules Dynamically

**VS Code Core (Workbench)** – The VS Code core (like the editor UI and built-in features) historically uses AMD modules with a custom loader. All TypeScript in VS Code’s source is compiled to AMD and loaded by a VS Code-maintained loader ([Migrating VS Code to Process Sandboxing](https://code.visualstudio.com/blogs/2022/11/28/vscode-sandbox#:~:text=Adapting%20our%20code%20loader)). Recently, the team has been transitioning to standard ECMAScript Modules (ESM) for the core. In fact, VS Code’s bootstrap code uses dynamic `import()` to load modules at runtime. For example, during startup VS Code computes a base URL to its installation `out` directory and then does:

```js
const result = await import(new URL(`${esModule}.js`, baseUrl).href);
```

This dynamic import loads the specified module file on the fly ([src/bootstrap-window.ts at main - truesoni/vscode](https://www.codefactor.io/repository/github/truesoni/vscode/source/main/src/bootstrap-window.ts#:~:text=try%20)). In other words, VS Code can resolve module paths to actual files and import them dynamically via ESM, at least for its own bundled code. This mechanism is used to load VS Code’s main renderer code and other pieces in a sandboxed environment.

**Extension Modules** – Extensions run in a separate _Extension Host_ process. Traditionally, extensions are written in CommonJS (Node-style) modules. The extension host uses Node’s module resolution (`require()`) to load an extension’s entry point from the extension’s install folder. Until recently, the extension host **only** supported CommonJS modules – attempts to load an ES module in an extension would fail with an error (`ERR_REQUIRE_ESM`) ([Enable consuming of ES modules in extensions · Issue #130367 · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/issues/130367#:~:text=The%20VS%20Code%20extension%20host,trimmed%29%20error%20message%20below)). Node’s error message for such cases explicitly says to “use import()” for ESM ([Load ES module from VS Code extension · Issue #915 · standard-things/esm · GitHub](https://github.com/standard-things/esm/issues/915#:~:text=Error%20,which)). This means an extension author _could_ leverage the dynamic `import()` function (which _is_ available in Node’s CommonJS context) to load an ES module at runtime as a workaround. In practice, if an extension depends on an npm package that is ESM-only, the extension can’t import it via `require()`, but can attempt `await import('module')`. However, this only works for local files – Node won’t fetch modules from the web via a bare import URL without additional tooling.

**Module Resolution Scope** – By default, VS Code’s module loader and extension host will **not** pull in arbitrary Node modules unless they are packaged. Extensions typically bundle their dependencies or list them in a `node_modules` folder within the extension. The VS Code extension runtime will resolve `require('some-package')` to the extension’s own `node_modules` (or bundled code). It does **not** automatically look at the user’s global `node_modules` or other folders, unless the extension’s code explicitly does so (for example, by constructing a file path to some module on disk). In other words, an extension can’t magically import a library from your machine’s global Node installation without some manual step. All required modules should be part of the extension itself (which is why VS Code documentation recommends **bundling extensions** to include their deps ([Bundling Extensions - Visual Studio Code](https://code.visualstudio.com/api/working-with-extensions/bundling-extension#:~:text=Bundling%20Extensions%20,VS%20Code%20on%20any%20platform))).

## Loading External Modules from Local or Internet Sources

**Local `node_modules`** – Normally, an extension must include any third-party libraries it uses. If an extension is missing a module, there is no built-in mechanism for VS Code to go out and load it from your system. In theory, an extension author could instruct users to manually install a dependency in a known location and then use Node’s require to load it. For example, one Stack Overflow solution suggests exposing a setting in the extension that points to an external script path, which the extension can then load ([javascript - How to load external JS from disk in a VS code extension? - Stack Overflow](https://stackoverflow.com/questions/42842398/how-to-load-external-js-from-disk-in-a-vs-code-extension#:~:text=Its%20an%20older%20question%2C%20still,see%20how%20to%20do%20it)). This is a hacky solution and not common. A more automated approach some extensions use is to programmatically run `npm install` on first activation – since extensions have full Node access, an extension could spawn a child process to install additional packages (or download files) when it activates. This is not typical or recommended (offline installations or corporate environments would frown on it), but it is possible. In short, **VS Code itself won’t load external modules from arbitrary locations unless the extension’s code explicitly does so**.

**Loading from the Internet** – Out of the box, Node’s module system does not support importing modules directly from URLs (unlike Deno or browser `<script>` tags). So an extension cannot simply do `import('http://example.com/mylib.js')` in Node. That said, an extension _can use network APIs_ to fetch and execute code. Because VS Code extensions are essentially unrestricted JavaScript running under your user account, a malicious or adventurous extension could download a script from the internet and execute it via `eval`, `Function(...)`, or by writing it to disk and requiring it. There are real examples of this: security researchers have found malicious VS Code extensions that **download obfuscated payloads** (like PowerShell scripts) from remote servers and run them ([Malicious Microsoft VSCode extensions target devs, crypto community](https://www.bleepingcomputer.com/news/security/malicious-microsoft-vscode-extensions-target-devs-crypto-community/#:~:text=match%20at%20L178%20and%20were,stage%20payloads%20from%20suspicious%20domains)) ([Malicious Microsoft VSCode extensions target devs, crypto community](https://www.bleepingcomputer.com/news/security/malicious-microsoft-vscode-extensions-target-devs-crypto-community/#:~:text=match%20at%20L196%20BleepingComputer%20found,that%C2%A0launch%20a%20hidden%20PowerShell%20command)). This is obviously not something a normal extension should do, but it demonstrates that it is technically possible to load and run external code at runtime. In benign scenarios, an extension might fetch data or code snippets from a server (for example, update a language server or rules), but this is done at the extension author’s discretion. There is no VS Code API that directly says “import module from URL” – it would be a manual network call followed by executing the received code.

**Web Extensions** – If we consider VS Code running in the browser (like on vscode.dev or GitHub Codespaces), the rules change. There, extensions run as web workers in the browser sandbox, so they can only use web APIs. A web extension _could_ use `fetch()` to get a script and then `importScripts` or dynamic import in a worker context, subject to CORS and content security policies. However, most web extensions are bundled into a single file ([Bundling Extensions - Visual Studio Code](https://code.visualstudio.com/api/working-with-extensions/bundling-extension#:~:text=Bundling%20Extensions%20,friendly)) for simplicity. Accessing an arbitrary CDN or `node_modules` on the internet is typically disallowed by CSP, so practically it’s rare for a web extension to load external code not included in its bundle.

## VS Code’s Security and Sandboxing Mechanisms

**Extension Host Isolation** – VS Code runs extensions in a separate process (or processes) from the renderer (UI). This design is both for stability (an extension crash won’t take down the UI) and for security. The extension host is a Node.js process with no direct access to VS Code’s DOM or internals except through the provided API. This means that an extension cannot directly monkey-patch the editor’s UI or intercept every keystroke unless an API is given for that. Extensions also run under the **user’s identity** – they have whatever file/system rights the user has, but not more. There is currently _no fine-grained permission model_: when you install an extension, you implicitly trust it completely. VS Code does **not** sandbox extension code like a web page; as one Stack Overflow answer bluntly puts it: _“They can contain malware, yes. When you download and run an extension, you are trusting it to do pretty much anything it wants with the permissions of your user. VS Code does not implement sandboxing (like browsers do), and the code is not much restricted.”_ ([security - How safe are extensions in Visual Studio code? - Stack Overflow](https://stackoverflow.com/questions/67493012/how-safe-are-extensions-in-visual-studio-code#:~:text=They%20can%20contain%20malware%2C%20yes,the%20permissions%20of%20your%20user)). In other words, an extension has free rein – it can read/write files, spawn processes, or even tamper with VS Code’s own files on disk.

**Sandboxed Renderer** – Starting in 2022, the VS Code team enabled Chromium’s **Electorn sandbox** for the renderer process (the window that shows the editor UI) ([Migrating VS Code to Process Sandboxing](https://code.visualstudio.com/blogs/2022/11/28/vscode-sandbox#:~:text=Enabling%20the%20sandbox%20in%20Electron,it%20evolved%20during%20this%20journey)) ([Migrating VS Code to Process Sandboxing](https://code.visualstudio.com/blogs/2022/11/28/vscode-sandbox#:~:text=applications%20such%20as%20Visual%20Studio,it%20evolved%20during%20this%20journey)). In sandboxed mode, the renderer no longer has Node.js enabled. This prevents random web content (like a malicious Markdown preview or a compromised webview) from calling Node APIs directly. The VS Code codebase had to be refactored so that all Node-dependent functionality moved out of the renderer into isolated processes (extension host, search, terminal, etc.) ([Migrating VS Code to Process Sandboxing](https://code.visualstudio.com/blogs/2022/11/28/vscode-sandbox#:~:text=As%20the%20previous%20topics%20have,results%20can%20be%20straight%20forward)) ([Migrating VS Code to Process Sandboxing](https://code.visualstudio.com/blogs/2022/11/28/vscode-sandbox#:~:text=Given%20that%20VS%20Code%20can,locally%20without%20a%20remote%20attached)). As a result, the core UI is closer to a browser environment – it can’t arbitrarily require Node modules at will. This is a security win: even if an attacker finds an XSS in VS Code’s UI, that exploit **cannot** directly execute OS commands unless it somehow jumps to the extension host or another process. (Electron apps that leave `nodeIntegration` on in the renderer are vulnerable to XSS = RCE; Slack’s engineers note that if nodeIntegration is enabled, any XSS can _“escalate to remote code execution (RCE) by calling `require('child_process').exec(...)`”_ ([The App Sandbox - Engineering at Slack](https://slack.engineering/the-app-sandbox/#:~:text=%2F%2F%20Since%20nodeIntegration%20is%20enabled%2C,return%20%60require%28%27child_process%27%29.exec)). VS Code’s sandboxing avoids that vector by disabling Node in the renderer.)

**Workspace Trust** – VS Code introduced _Workspace Trust_ to mitigate the risk of automatic code execution when opening untrusted projects. By default, if you open a folder from the internet or unknown source, VS Code will disable or restrict extension functionality until you explicitly mark the workspace as trusted. This helps prevent scenarios like opening a malicious repo that triggers an extension to run tasks or code. However, Workspace Trust primarily affects _when_ extensions activate and what tasks/debug scripts can run ([Visual Studio Code Remote Code Execution Vulnerability CVE-2022-41034](https://www.uptycs.com/blog/threat-research-report-team/visual-studio-code-remote-execution-vulnerability-cve-2022-41034#:~:text=Visual%20Studio%20Code%20imposes%20varying,link)). Once you trust a workspace (or if you disable the feature), the extensions operate normally. At that point, all security bets rely on the extension’s own behavior.

**No Native Permission System** – Unlike mobile apps or some browsers, VS Code does not ask for permissions like “This extension wants to access files/network”. As researchers have pointed out, there is a _“lack of a permission model”_ and _“unrestricted capabilities”_ for extensions ([Malicious VSCode extensions with millions of installs discovered : r/programming](https://www.reddit.com/r/programming/comments/1dcz9uj/malicious_vscode_extensions_with_millions_of/#:~:text=Actually%20during%20our%20research%20of,who%20use%20Visual%20Studio%20Code)). Microsoft relies on the marketplace review process and community vigilance to catch malicious extensions. The code is not sandboxed, but if something malicious is found, the extension can be removed from the marketplace. Still, during the time it’s installed, it has full ability to modify your environment. Code signing of extensions (VSIX files) ensures they aren’t tampered in transit, but it doesn’t restrict what the code can do once running ([security - How safe are extensions in Visual Studio code? - Stack Overflow](https://stackoverflow.com/questions/67493012/how-safe-are-extensions-in-visual-studio-code#:~:text=VS%20Code%20does%20not%20implement,code%20is%20not%20much%20restricted)).

## Can You Inject Third-Party Modules into VS Code’s Core?

By design, **there is no official API to inject arbitrary code into VS Code’s core UI or override built-in modules**. The extension API provides well-defined _contribution points_ (commands, editors, theming, etc.), but it doesn’t let you, say, replace VS Code’s file explorer with your own script by importing a new module into it. The VS Code team deliberately keeps internal modules private – extensions only interact with VS Code through the `vscode` API object, not by importing VS Code’s internal code.

That said, because extensions execute with full privileges, clever developers have found ways to **monkey-patch** or extend VS Code beyond the official API:

- **Monkey Patch Extension**: A popular extension called **Monkey Patch** exists explicitly to _“allow execution of arbitrary JavaScript in VSCode’s browser and main process”_ ([
  Monkey Patch - Visual Studio Marketplace
  ](https://marketplace.visualstudio.com/items?itemName=iocave.monkey-patch#:~:text=What%20does%20it%20do)). It works by injecting custom scripts into VS Code at startup. For example, Monkey Patch can load user-provided JS files **into the main process or renderer process** of VS Code ([
  Monkey Patch - Visual Studio Marketplace
  ](https://marketplace.visualstudio.com/items?itemName=iocave.monkey-patch#:~:text=%2F%2F%20Will%20load%20%22~%2Fcustom,modules%2FmainProcess1%22)) ([
  Monkey Patch - Visual Studio Marketplace
  ](https://marketplace.visualstudio.com/items?itemName=iocave.monkey-patch#:~:text=let%20monkeyPatch%20%3D%20vscode.extensions.getExtension%28%22iocave.monkey)). This effectively lets you import third-party code into VS Code’s core context. Under the hood, this extension modifies VS Code’s installation (it may patch files or use VS Code’s startup hooks) to insert your code. It even maps custom module names to user-specified folders so it can `require` them as if they were part of VS Code ([
  Monkey Patch - Visual Studio Marketplace
  ](https://marketplace.visualstudio.com/items?itemName=iocave.monkey-patch#:~:text=%22monkeyPatch.folderMap%22%3A%20%7B%20%22my,modules%2FmainProcess.js%22%20in%20main%20process)). The Customize UI extension leverages Monkey Patch for deep UI tweaks: _“Customize UI relies on the Monkey Patch extension to inject custom JavaScript in VSCode.”_ ([GitHub - iocave/customize-ui: UI Customization plugin for vscode](https://github.com/iocave/customize-ui#:~:text=Customize%20UI%20relies%20on%20the,command)). This is a **unsupported hack** – powerful, but potentially fragile. Every time VS Code updates, Monkey Patch needs to adjust (it even prompts the user to re-patch if things changed ([
  Monkey Patch - Visual Studio Marketplace
  ](https://marketplace.visualstudio.com/items?itemName=iocave.monkey-patch#:~:text=Monkey%20Patch%20aims%20to%20make,request%20elevated%20privileges%20if%20necessary))). Using it can break VS Code or cause instability if the injected code misbehaves, so it’s only for advanced users.

- **Requiring Internal Modules**: Since extensions run in Node and have file system access, an extension could in theory locate VS Code’s installation files and attempt to `require()` internal code modules. For example, VS Code’s source has files under `.../out/vs/...`. A determined developer might try to load these to call undocumented functions. This is **not recommended** – those paths can change, and in sandboxed VS Code the renderer’s modules won’t work in the extension host context anyway. There’s no guarantee such hacks will continue to work across versions. It’s generally better to use official APIs, or request new APIs, than to import VS Code’s own code.

- **Exploits and Vulnerabilities**: There have been security exploits where opening a certain file could execute commands (for instance, a malicious notebook file could bypass VS Code’s content safety and run a `command:` URI ([Visual Studio Code Remote Code Execution Vulnerability CVE-2022-41034](https://www.uptycs.com/blog/threat-research-report-team/visual-studio-code-remote-execution-vulnerability-cve-2022-41034#:~:text=Visual%20Studio%20Code%20imposes%20varying,link))). Those are essentially _bugs_ – not intended extension points. They don’t involve importing third-party modules, but show that if an attacker can trick VS Code into running a payload, it can compromise the system. These are typically patched once discovered (e.g. CVE-2022-41034 was fixed in 1.72.1). Such exploits are beyond the scope of normal extension development, but they underscore why VS Code tightened sandboxing.

## Documented Workarounds or APIs for Arbitrary Imports

There is no official supported API like “load this JS library into VS Code’s core.” Any solution is a workaround:

- The **Monkey Patch** extension _is_ a documented workaround (with its own API for other extensions to use it ([
  Monkey Patch - Visual Studio Marketplace
  ](https://marketplace.visualstudio.com/items?itemName=iocave.monkey-patch#:~:text=let%20monkeyPatch%20%3D%20vscode.extensions.getExtension%28%22iocave.monkey))). It’s essentially an exploit turned feature – modifying VS Code’s code at runtime. This lets developers do things not normally possible, such as altering how the workbench behaves or styling things not exposed via theming.

- If your goal is to use an **external library within your extension**, the standard approach is to bundle that library. If it’s huge and you want to lazy-load it, you can use dynamic `import()` in your extension code. For instance, an extension could on demand do `const lib = await import(pathToScript)`. The path could even be in the extension’s `node_modules` folder on disk that isn’t pre-bundled (as long as the file exists). This isn’t injecting into _VS Code core_, but it’s how you’d load third-party code on the fly in your extension. Some extensions might ship minimal code and then download additional code after activation (to reduce VSIX size or evade static analysis). This is technically possible, though users would likely object if they knew an extension does this without transparency.

- **Electron ASAR Patching**: In Electron apps, one could modify the app’s `app.asar` package (which contains most of the source code) to insert new require calls. This is exactly what Monkey Patch does under the hood – it requests elevated privileges to alter VS Code’s installed files ([
  Monkey Patch - Visual Studio Marketplace
  ](https://marketplace.visualstudio.com/items?itemName=iocave.monkey-patch#:~:text=Monkey%20Patch%20aims%20to%20make,request%20elevated%20privileges%20if%20necessary)). Electron does not sign or checksum the ASAR at runtime, so modifications aren’t detected ([> The problem lies in the fact that Electron ASAR files themselves are not encry... | Hacker News](https://news.ycombinator.com/item?id=20637036#:~:text=When%20you%20download%20an%20application,tag%20and%20let%27s%20it%20launch)) ([> The problem lies in the fact that Electron ASAR files themselves are not encry... | Hacker News](https://news.ycombinator.com/item?id=20637036#:~:text=Once%20that%20quarantine%20tag%20is,the%20application%20is%20first%20launched)). It’s an “exploit” in the loose sense (anyone who can write to the app files can inject code). But it requires disk access. A VS Code extension running as the user can perform such modifications. Without using Monkey Patch, doing this manually is complex and risky (and obviously **not supported** by Microsoft).

In summary, **arbitrary module loading is not something VS Code encourages**, but the openness of the extension environment means determined developers have found ways to do it. Official docs mostly focus on bundling your code and using the extension API, rather than dynamic injection.

## Examples of External Dependency Injection

- **Monkey Patch & Customize UI** – As discussed, these demonstrate _successful injection of external scripts_ into VS Code. The Customize UI extension authors wanted to change VS Code’s appearance in ways the API didn’t allow, so they literally inject code at startup to override VS Code’s UI methods ([GitHub - iocave/customize-ui: UI Customization plugin for vscode](https://github.com/iocave/customize-ui#:~:text=Customize%20UI%20relies%20on%20the,command)). Over 200k installs of Monkey Patch show there is demand for this level of customization, albeit with caution ([
  Monkey Patch - Visual Studio Marketplace
  ](https://marketplace.visualstudio.com/items?itemName=iocave.monkey-patch#:~:text=240%2C536%20installs)).

- **Malicious Extensions** – Unfortunately, there are examples of attackers leveraging VS Code’s freedom. In late 2024, researchers found a wave of malicious extensions that were **downloading obfuscated second-stage payloads** from external URLs after installation ([Malicious Microsoft VSCode extensions target devs, crypto community](https://www.bleepingcomputer.com/news/security/malicious-microsoft-vscode-extensions-target-devs-crypto-community/#:~:text=match%20at%20L178%20and%20were,stage%20payloads%20from%20suspicious%20domains)) ([Malicious Microsoft VSCode extensions target devs, crypto community](https://www.bleepingcomputer.com/news/security/malicious-microsoft-vscode-extensions-target-devs-crypto-community/#:~:text=and%20were%20designed%20to%20download,stage%20payloads%20from%20suspicious%20domains)). These payloads (PowerShell scripts, in that case) were then executed to steal data. This is an example of importing code from the internet (albeit not via ES module import, but by fetch + execute). Another example reported by SonarSource involved an extension using the Markdown preview to run unintended code. These cases show that if someone wants to pull in code from elsewhere (be it a third-party library or a malicious script), an extension can do it unless blocked by network firewalls or Workspace Trust restrictions. VS Code’s Marketplace now does some scanning for obvious malware patterns, but it’s still largely a trust-based system ([Malicious VSCode extensions with millions of installs discovered : r/programming](https://www.reddit.com/r/programming/comments/1dcz9uj/malicious_vscode_extensions_with_millions_of/#:~:text=Actually%20during%20our%20research%20of,who%20use%20Visual%20Studio%20Code)).

- **ESM in Extensions** – A more positive example: as Node.js and VS Code evolve, we might see extensions officially using ESM modules. The issue 【130367】 on VS Code’s GitHub was about allowing extension hosts to consume ES modules. VS Code 1.78+ (mid-2023) introduced preliminary support for ESM in extensions when using `pnpm` and workspace schemas, but CommonJS remains the norm. A developer on StackOverflow described trying to use the `esm` Node package or dynamic import to load an ES module in an extension ([Load ES module from VS Code extension · Issue #915 · standard-things/esm · GitHub](https://github.com/standard-things/esm/issues/915#:~:text=%5B2022,getport%2Fout%2Fmain.js%3A4%3A20)) ([Load ES module from VS Code extension · Issue #915 · standard-things/esm · GitHub](https://github.com/standard-things/esm/issues/915#:~:text=Error%20,test)). The error they hit (require ESM) and the discussion around it is a good example of the _technical friction_ when trying to bring in third-party code of a different module type. The workaround was indeed to use `import()` at runtime, illustrating that injection of a module was possible with a bit of dynamic loading.

## Comparisons with Other Electron Apps

VS Code’s approach is somewhat unique because it actively supports a rich extension ecosystem. Other Electron-based apps often take a more locked-down approach:

- **Electron Apps without Plugins** – Apps like **Slack, Discord, Skype** (all Electron-based) do not allow third-party plugins or code execution by the user. They ship all code from the vendor. These apps typically disable Node integration in any window that renders remote content. Slack, for instance, enabled the Chromium sandbox for all its web content and turned off the ability for that content to use Node APIs ([The App Sandbox - Engineering at Slack](https://slack.engineering/the-app-sandbox/#:~:text=,but%20it%E2%80%99s%20double%20safe%20now)) ([The App Sandbox - Engineering at Slack](https://slack.engineering/the-app-sandbox/#:~:text=%2F%2F%20Since%20nodeIntegration%20is%20enabled%2C,return%20%60require%28%27child_process%27%29.exec)). This means even if an attacker injects a script via an XSS, it can’t `require('fs')` or import malware – the worst it can do is something within the browser environment unless it exploits a Chrome bug. In VS Code’s case, by contrast, the product _intentionally_ allows running code (extensions) that is not written by Microsoft, so the threat model is different. VS Code mitigates risk by isolating processes, whereas Slack mitigates by not allowing any unknown code at all in the core process.

- **Atom Editor** – GitHub’s Atom editor (now discontinued) was also Electron-based and had a very permissive model for extensions (Atom packages). In Atom, packages ran in the renderer process with full Node integration. It even let users add an `init.coffee` script that runs on startup, effectively letting the user inject whatever code they want into Atom’s core. This is analogous to what Monkey Patch enables in VS Code, though Atom made it a built-in feature. The downside was similar: any package had full access to Node and the DOM, so a malicious package could do damage. There was no sandbox or permission prompt – just like VS Code, you had to trust the community and authors. The key difference is VS Code’s architecture (separating extension host) provides a bit more stability and the opportunity (in the future) to sandbox extensions more easily. Atom did none of that, which was simpler but arguably less secure.

- **Other Apps with Plugins** – Some other developer tools (like **Obsidian**, a note-taking app, or **Joplin**) allow community plugins. They too face the same choices: either run plugins in a sandbox (which limits capabilities) or run them with trust. Obsidian chooses to trust plugins fully (similar to VS Code’s model, with warnings), whereas Joplin uses a sandboxed plugin script runner (more akin to a browser environment). The trend for better security is sandboxing untrusted code. VS Code’s partial sandboxing (for the renderer) and workspace trust are steps in that direction, but **extension code is still unsandboxed** as of 2025.

- **Electron Security Guidance** – The Electron project itself provides security guidelines (disable `nodeIntegration`, enable `contextIsolation`, use `app.whenReady()` to limit risk, etc.). Many Electron apps now ship with `contextIsolation: true` (separating the global window context from the Electron/Node context) and `nodeIntegration: false` in any window that shows non-trusted content ([Node integration in electron apps? : r/electronjs - Reddit](https://www.reddit.com/r/electronjs/comments/cd7b6y/node_integration_in_electron_apps/#:~:text=Node%20integration%20in%20electron%20apps%3F,window%20because%20of%20potential)). VS Code’s use of a preload script and sandbox for its renderer aligns with these practices. But the extension host (being a separate Node process) doesn’t expose a GUI that an attacker can directly script; it’s more like a server on your machine that the VS Code UI calls into. If someone wanted to “inject a module” into an Electron app like Slack, they’d have to tamper with its files on disk (which has been demonstrated due to ASAR not being re-checked ([> The problem lies in the fact that Electron ASAR files themselves are not encry... | Hacker News](https://news.ycombinator.com/item?id=20637036#:~:text=When%20you%20download%20an%20application,tag%20and%20let%27s%20it%20launch))). With VS Code, you can achieve similar tampering via an extension like Monkey Patch without manually editing files – the extension automates it.

## Key Takeaways

- **VS Code can dynamically load modules**, but primarily for its own code (using AMD/ESM loaders). Extensions are expected to bundle dependencies; there’s no built-in support to auto-load modules from outside an extension’s package.

- **Loading third-party code at runtime is _possible_** (extensions can fetch and eval code, or use dynamic import for local files), but it’s not _safe_ or straightforward. Doing so is effectively running unvetted code with your privileges.

- **Security mechanisms in VS Code** focus on process isolation and user trust decisions, rather than preventing code execution. Extensions run with full power – no sandbox, no permission prompts ([security - How safe are extensions in Visual Studio code? - Stack Overflow](https://stackoverflow.com/questions/67493012/how-safe-are-extensions-in-visual-studio-code#:~:text=They%20can%20contain%20malware%2C%20yes,the%20permissions%20of%20your%20user)). The main VS Code UI is now sandboxed from Node, which stops certain attack paths but doesn’t restrict what extensions can do.

- **There are no official APIs to inject code into the VS Code core UI**, but extensions like Monkey Patch show it can be done by modifying VS Code’s own files or environment ([
  Monkey Patch - Visual Studio Marketplace
  ](https://marketplace.visualstudio.com/items?itemName=iocave.monkey-patch#:~:text=What%20does%20it%20do)). This is advanced and comes with risks of breaking on updates.

- **Examples from the wild** range from legitimate customization (Customize UI injecting CSS/JS into VS Code via Monkey Patch ([GitHub - iocave/customize-ui: UI Customization plugin for vscode](https://github.com/iocave/customize-ui#:~:text=Customize%20UI%20relies%20on%20the,command))) to malicious attacks (fake extensions downloading and running malware ([Malicious Microsoft VSCode extensions target devs, crypto community](https://www.bleepingcomputer.com/news/security/malicious-microsoft-vscode-extensions-target-devs-crypto-community/#:~:text=match%20at%20L178%20and%20were,stage%20payloads%20from%20suspicious%20domains)) ([Malicious Microsoft VSCode extensions target devs, crypto community](https://www.bleepingcomputer.com/news/security/malicious-microsoft-vscode-extensions-target-devs-crypto-community/#:~:text=match%20at%20L196%20BleepingComputer%20found,that%C2%A0launch%20a%20hidden%20PowerShell%20command))). Both rely on the fact that once you can run extension code, you can pretty much do anything.

- **Compared to other Electron apps**, VS Code is more permissive by design (to enable extensions). Other apps avoid dynamic code loading entirely or heavily sandbox it. This is a conscious trade-off in VS Code’s architecture to favor extensibility.

In conclusion, **injecting third-party modules into VS Code’s core** isn’t something the platform supports out-of-the-box, but the openness of the extension system means it can be accomplished through workarounds. One must weigh the use case against the security implications. For most developers, using the extension API and bundling needed libraries is the way to go. Only in special scenarios (or for security researchers) should techniques like runtime code injection or monkey-patching be used – and with extreme caution.

**Sources:**

- VS Code’s use of AMD vs ESM modules ([Migrating VS Code to Process Sandboxing](https://code.visualstudio.com/blogs/2022/11/28/vscode-sandbox#:~:text=Adapting%20our%20code%20loader)) ([src/bootstrap-window.ts at main - truesoni/vscode](https://www.codefactor.io/repository/github/truesoni/vscode/source/main/src/bootstrap-window.ts#:~:text=try%20))
- Extension host module format limitations (CommonJS only) ([Enable consuming of ES modules in extensions · Issue #130367 · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/issues/130367#:~:text=The%20VS%20Code%20extension%20host,trimmed%29%20error%20message%20below)) ([Load ES module from VS Code extension · Issue #915 · standard-things/esm · GitHub](https://github.com/standard-things/esm/issues/915#:~:text=Error%20,which))
- Bundling extensions and module resolution ([Bundling Extensions - Visual Studio Code](https://code.visualstudio.com/api/working-with-extensions/bundling-extension#:~:text=Bundling%20Extensions%20,VS%20Code%20on%20any%20platform))
- Stack Overflow – VS Code not sandboxing extensions (user trust) ([security - How safe are extensions in Visual Studio code? - Stack Overflow](https://stackoverflow.com/questions/67493012/how-safe-are-extensions-in-visual-studio-code#:~:text=They%20can%20contain%20malware%2C%20yes,the%20permissions%20of%20your%20user))
- VS Code sandboxing blog (process isolation and removal of Node from renderer) ([Migrating VS Code to Process Sandboxing](https://code.visualstudio.com/blogs/2022/11/28/vscode-sandbox#:~:text=Enabling%20the%20sandbox%20in%20Electron,it%20evolved%20during%20this%20journey)) ([Migrating VS Code to Process Sandboxing](https://code.visualstudio.com/blogs/2022/11/28/vscode-sandbox#:~:text=As%20the%20previous%20topics%20have,results%20can%20be%20straight%20forward))
- Reddit comment on lack of extension permission model ([Malicious VSCode extensions with millions of installs discovered : r/programming](https://www.reddit.com/r/programming/comments/1dcz9uj/malicious_vscode_extensions_with_millions_of/#:~:text=Actually%20during%20our%20research%20of,who%20use%20Visual%20Studio%20Code))
- Monkey Patch extension documentation ([
  Monkey Patch - Visual Studio Marketplace
  ](https://marketplace.visualstudio.com/items?itemName=iocave.monkey-patch#:~:text=What%20does%20it%20do)) ([
  Monkey Patch - Visual Studio Marketplace
  ](https://marketplace.visualstudio.com/items?itemName=iocave.monkey-patch#:~:text=%2F%2F%20Will%20load%20%22~%2Fcustom,modules%2FmainProcess1%22))
- Customize UI note on injecting JS via Monkey Patch ([GitHub - iocave/customize-ui: UI Customization plugin for vscode](https://github.com/iocave/customize-ui#:~:text=Customize%20UI%20relies%20on%20the,command))
- BleepingComputer – malicious extensions downloading payloads ([Malicious Microsoft VSCode extensions target devs, crypto community](https://www.bleepingcomputer.com/news/security/malicious-microsoft-vscode-extensions-target-devs-crypto-community/#:~:text=and%20were%20designed%20to%20download,stage%20payloads%20from%20suspicious%20domains)) ([Malicious Microsoft VSCode extensions target devs, crypto community](https://www.bleepingcomputer.com/news/security/malicious-microsoft-vscode-extensions-target-devs-crypto-community/#:~:text=match%20at%20L196%20BleepingComputer%20found,that%C2%A0launch%20a%20hidden%20PowerShell%20command))
- Slack engineering blog – enabling app sandbox (Node integration off) ([The App Sandbox - Engineering at Slack](https://slack.engineering/the-app-sandbox/#:~:text=%2F%2F%20Since%20nodeIntegration%20is%20enabled%2C,return%20%60require%28%27child_process%27%29.exec)) ([The App Sandbox - Engineering at Slack](https://slack.engineering/the-app-sandbox/#:~:text=,but%20it%E2%80%99s%20double%20safe%20now)).
