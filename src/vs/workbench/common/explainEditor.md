I'll gather an in-depth review of the VS Code internal editing framework, focusing on its architecture, how edits are processed internally, how working copies function in relation to models, and the key classes and components involved in the editor. This will include details on buffer management, undo/redo handling, how editor input flows through the system, and other relevant internal mechanisms for contributions to VS Code.

I'll get back to you with the findings soon.

# VS Code Core Editing Framework – In-Depth Technical Review

## Architecture Overview of the Editing Framework and Key Components

Visual Studio Code’s core editing framework is built around a **Model-View architecture** that separates the UI/editor from the underlying data model. Key components include:

- **Text Buffer & TextModel** – The low-level text storage and model logic. VS Code (via the Monaco editor) uses a **piece table** data structure for text buffers, which maintains two underlying string buffers (one for original file content, one for appended edits) and a list of “pieces” referencing parts of these buffers ([Text Buffer Reimplementation, a Visual Studio Code Story](https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation#:~:text=After%20the%20file%20is%20initially,a%20new%20one%20as%20needed)) This structure efficiently represents sequential edits (appending new text adds a piece referencing the “added” buffer) and even mid-document changes (splitting an existing piece and inserting a new one) ([Text Buffer Reimplementation, a Visual Studio Code Story](https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation#:~:text=append%20the%20new%20content%20to,a%20new%20one%20as%20needed)) The **TextModel** in VS Code is the in-memory representation of an open text document. It wraps the text buffer, tracks content, and emits events for changes. It also handles things like text encoding, line endings, and marker decorations.

- **Editor (UI)** – The visible code editor widget (based on Monaco). This provides the rendering of text, cursors, selections, and decorations (like highlights or squiggly underlines). It interacts with a TextModel for content. VS Code’s editor is a **“code editor control”** that can be created for any TextModel; multiple editor instances can display the same TextModel (for example, the same file open side-by-side).

- **EditorInput** – A lightweight object representing a resource to edit (e.g. a file URI, an untitled buffer, a diff of two resources). It acts as the identifier for an editor instance and is used by the workbench to track open editors. For example, clicking the same file twice will reuse the same EditorInput instance rather than creating a new one. (Indeed, VS Code reuses EditorInput objects for the same resource across editor tabs and splits. The workbench will only dispose an EditorInput when the _last_ editor using it is closed ([[Custom Editors API] onDidDispose is not always called on WebviewPanel · Issue #88229 · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/issues/88229#:~:text=%40mjbvz%20it%20is%20intentional%20that,the%20last%20editor%20was%20closed)) ([[Custom Editors API] onDidDispose is not always called on WebviewPanel · Issue #88229 · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/issues/88229#:~:text=editors,the%20last%20editor%20was%20closed)) ) EditorInput subclasses exist for different types of editors (text files, untitled files, custom editors, diff views, etc.), often carrying the URI of the resource and perhaps some additional metadata.

- **EditorModel** – The heavyweight counterpart to an EditorInput. Whereas EditorInput is mostly an identifier/handle, an EditorModel contains the actual document data or the mechanism to load/save it. For text files, this is often called a **TextFileEditorModel**, which encapsulates a TextModel (the content) and file I/O logic. Creating or opening an EditorInput will usually trigger resolving or loading an EditorModel (e.g. reading file contents from disk into a TextModel). EditorModels are cached and reused when possible because they can be expensive to create (e.g. reading large files) ([CoCalc -- editorModel.ts](https://cocalc.com/github/microsoft/vscode/blob/main/src/vs/workbench/common/editor/editorModel.ts#:~:text=,on%20the%20editor%20input%2C%20it)) ([CoCalc -- editorModel.ts](https://cocalc.com/github/microsoft/vscode/blob/main/src/vs/workbench/common/editor/editorModel.ts#:~:text=,they%20are%20expensive%20to%20construct)) An EditorModel typically knows how to **resolve** (load) its content and how to **save or revert** it back to the backing store (if any). When an EditorModel is no longer needed and all references are released, it is disposed (freeing memory like the TextModel, event listeners, etc.).

- **Working Copy** – An internal abstraction introduced to unify how _dirty_ (modified, unsaved) editors are handled across different editor types (text files, custom editors, notebooks, etc.). A working copy represents an editable document in the editor _that may have unsaved changes_. The **IWorkingCopy** interface defines a few essential pieces: a `resource` URI (unique identifier), a `typeId` (to distinguish different editor types), and events like `onDidChangeDirty`, `onDidChangeContent`, `onDidSave` for change tracking ([Working Copies · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Working-Copies#:~:text=,the%20workbench%20to%20call%20on)) It also defines methods like `save`, `revert`, and `backup` for persistence ([Working Copies · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Working-Copies#:~:text=,the%20workbench%20to%20call%20on)) In VS Code’s text editor, the TextFileEditorModel itself implements IWorkingCopy ([Working Copies · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Working-Copies#:~:text=directly%20onto%20the%20working%20copy,working%20copy%20that%20gets%20registered)) – effectively the text file model _is_ the working copy for that resource. Working copies allow the workbench to manage autosave, dirty state, and hot-exit backups in a uniform way for any editable entity.

- **Editor Part & Groups** – The workbench UI component that holds editors. VS Code can have multiple editor _groups_ (columns) open. Each group can contain multiple open EditorInputs (with their EditorModels), one of which is active/visible. The **EditorGroupsService** manages these groups, their order, and events when the active editor or layout changes. The **EditorService** acts as a high-level service to open editors in groups, controlling the creation of editor widgets and loading of models. When an editor is opened through the EditorService, it identifies if an EditorInput for that resource already exists (in which case it reuses it); if not, it creates a new one and associates it with the appropriate EditorModel.

In summary, the architecture cleanly separates the concerns: **TextModels** manage content and low-level edits, **EditorModels** provide an interface to load/save that content (and tie into the working copy system), **EditorInputs** represent the identity of opened documents in the UI, and the **editor UI** renders the content. Surrounding services like the **WorkingCopyService**, **EditorService**, and **EditorGroupsService** coordinate these pieces (e.g., tracking dirty files, orchestrating editor opening/closing, and preserving UI state).

## Flow of an Edit: From User Input to Persistence

When a user makes an edit in VS Code, the change flows through several layers from the keyboard input to disk persistence:

1. **User Input in the Editor** – The user types or deletes text in the code editor. The editor UI captures these key events and translates them into text operations (insert character, delete selection, etc.). The Monaco editor then applies these operations to the underlying TextModel’s buffer. Thanks to the piece table buffer, inserting text doesn’t require rewriting the entire file in memory – e.g. typing adds a new piece referencing the “added” buffer with the new text ([Text Buffer Reimplementation, a Visual Studio Code Story](https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation#:~:text=After%20the%20file%20is%20initially,a%20new%20one%20as%20needed))

2. **TextModel Content Update** – The TextModel processes the edit operation. Internally, it adjusts the piece table (or other data structure) to reflect the new content. The TextModel generates a new _version id_ for the content and records the edit in its **edit stack** for undo/redo (discussed later). It then emits a content change event. For example, the TextModel’s `onDidChangeContent` event is fired with details of the text edit (what text, which range, etc.) ([vscode/src/vs/editor/common/model/textModel.ts at main · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/editor/common/model/textModel.ts#:~:text=private%20readonly%20_eventEmitter%3A%20DidChangeContentEmitter%20%3D,register%28new%20DidChangeContentEmitter)) This event notifies all listeners that the document’s content in memory has changed.

3. **Working Copy Dirty Flag** – The text file’s EditorModel (which, for files, is a TextFileEditorModel) listens to the TextModel changes. Upon the first edit after a save, it will mark itself as **dirty** (unsaved). The WorkingCopyService is also notified via the `onDidChangeDirty` event that this working copy is now dirty ([Working Copies · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Working-Copies#:~:text=,the%20workbench%20to%20call%20on)) The UI will update – for example, the editor tab shows an “●” indicator that the file has unsaved changes. At this moment, the changes are only in memory (in the TextModel); the file on disk is untouched.

4. **Backup (Hot Exit)** – When a working copy’s content changes and it becomes dirty, VS Code’s backup system may prompt the working copy to persist a backup. The `IWorkingCopyService` will call the working copy’s `backup()` method, passing it a location to save a snapshot (and the model provides its content) ([Working Copies · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Working-Copies#:~:text=Providing%20Backups)) This allows VS Code to restore your edits after a crash or restart (the “hot exit” feature). The backup is typically just the dirty content saved to a temporary location. Backups are automatically cleared when the file is saved (i.e., no longer dirty) ([Working Copies · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Working-Copies#:~:text=,object%20associated%20with%20the%20backup)) ([Working Copies · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Working-Copies#:~:text=Note%3A%20backups%20are%20automatically%20deleted,no%20longer%20reports%20as%20dirty))

5. **Language Features Reaction** – The content change event also propagates to language services and decorations (more on this in a later section). For instance, if you have a linting error on a line and you fix it, the content change will cause the diagnostics (markers) to update, removing the error squiggle. Similarly, features like auto-indentation or bracket pair colorization may react immediately to the inserted character via these events.

6. **User Triggers Save** – When the user saves the file (manually via **Ctrl+S** or via auto-save timer), the workbench calls into the EditorModel’s `save()` method. For a text file, this involves gathering the latest content from the TextModel and writing it to disk. The **TextFileEditorModel** uses the VS Code file service (`IFileService`) to perform the write, which might go to the local filesystem or a remote store depending on the URI scheme.

7. **Persist to Disk and Events** – After a successful write, the TextFileEditorModel clears its dirty state (and the WorkingCopyService in turn emits that the working copy is no longer dirty). The model also raises an `onDidSave` event to signal that content was saved ([Working Copies · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Working-Copies#:~:text=Save%2FRevert)) The UI will remove the dirty indicator on the tab. If the file was new (untitled), a save may also result in the EditorInput being replaced (e.g., an UntitledEditorInput is disposed and replaced by a TextFileEditorInput for the new file URI once it’s saved to a real file).

8. **Continued Editing** – The user can continue editing after a save; new edits will increment the model version, mark dirty again, etc. The cycle repeats. If the user decides to close an editor with unsaved changes, VS Code will either prompt to save or (if hot-exit is enabled and the user trusts it) just store a backup and exit. On next launch, the backup is used to restore the editor in its last state (via the working copy restoration mechanism ([Working Copies · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Working-Copies#:~:text=Restoring%20Backups)) .

Throughout this flow, the **data is synchronized** between the in-memory model and the on-disk file only on explicit actions like save or revert. Simply typing modifies the in-memory TextModel (which is very fast and can handle large files efficiently), and VS Code’s working copy system keeps track of what’s dirty and needs saving. For contributors looking to hook into this flow, the key points are the events (content change, dirty change, save) and the services (WorkingCopyService, FileService) that mediate between the model and persistence. For example, if implementing a new editor type, you’d want to fire `onDidChangeDirty` and `onDidSave` events at appropriate times so that auto-save and backups work seamlessly ([Working Copies · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Working-Copies#:~:text=Save%2FRevert))

## EditorInput vs EditorModel vs TextModel: Relationship and Roles

These three concepts form a chain from the **workbench UI down to the text content**:

- **EditorInput** – Represents an open editor _instance_. It is primarily an identifier or pointer to what is being edited. For text files, the EditorInput usually holds a URI to the file and perhaps a title or icon. It does not contain the file’s text content itself. Think of EditorInput as the object that goes into a tab or an editor slot – it answers “what are we editing and how do we refer to it”. All editor inputs derive from the base `EditorInput` class (for example: `TextResourceEditorInput` for normal files, `UntitledTextEditorInput` for new unsaved files, `DiffEditorInput` for a two-pane diff view, etc.). The workbench often checks EditorInputs for equality or matches by their resource; if you open the same file in two splits, both splits reference the _same_ EditorInput instance (to avoid duplicating work and to ensure consistent state) ([[Custom Editors API] onDidDispose is not always called on WebviewPanel · Issue #88229 · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/issues/88229#:~:text=%40mjbvz%20it%20is%20intentional%20that,the%20last%20editor%20was%20closed)) EditorInputs handle things like generating the tab label, determining if they are readonly or untitled, and they may provide a way to serialize/deserialize editor state.

- **EditorModel** – Holds the contents or data being edited, and the logic to load or save that data. Each EditorInput can be associated with an EditorModel (accessible via `EditorInput.resolve()` which loads the model). For a file, the EditorModel reads the file from disk (or cache) and creates a TextModel with the file’s text. The EditorModel is responsible for the lifecycle of that content: it tracks whether it’s loaded, monitors the file for external changes (if a file is changed on disk, the model might need to update or at least mark itself out-of-date), handles saving the content, and provides undo/redo integration. The base `EditorModel` class in VS Code is a generic abstraction, but concrete subclasses do the real work (e.g. `TextFileEditorModel` for text files, `BinaryEditorModel` for binary files, etc.). As the documentation notes, an EditorModel is considered the **“heavyweight”** counterpart to an EditorInput, often involving I/O or significant setup ([CoCalc -- editorModel.ts](https://cocalc.com/github/microsoft/vscode/blob/main/src/vs/workbench/common/editor/editorModel.ts#:~:text=,on%20the%20editor%20input%2C%20it)) Because of this, VS Code often **caches EditorModels** – if you close a file and reopen it shortly after, it may reuse the already-loaded model from memory rather than reading the file again, for performance. EditorModels emit an `onWillDispose` event before they are finally disposed, giving extensions or other parts of the code a chance to cleanup references ([CoCalc -- editorModel.ts](https://cocalc.com/github/microsoft/vscode/blob/main/src/vs/workbench/common/editor/editorModel.ts#:~:text=15))

- **TextModel** – This is the actual in-memory representation of text content (provided by the Monaco editor module, but integrated into VS Code). A TextModel is essentially the text buffer plus rich metadata: it knows the text of the document, the language mode (syntax), track of all positions and line numbers, and can efficiently answer queries about the text. It’s also responsible for emitting **fine-grained events** about content changes (for example, an `IModelContentChangedEvent` for text insertions/deletions) ([vscode/src/vs/editor/common/model/textModel.ts at main · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/editor/common/model/textModel.ts#:~:text=private%20readonly%20_eventEmitter%3A%20DidChangeContentEmitter%20%3D,register%28new%20DidChangeContentEmitter)) The TextModel provides text-editing operations (like applying edits, getting ranges, searching, etc.) and holds the **undo/redo stack** for the document. In VS Code’s design, the EditorModel often contains or wraps a TextModel. For instance, `TextFileEditorModel` on resolve will create a Monaco TextModel for the file’s contents, and dispose of it when done. The TextModel is also what language features work against (for example, when the user requests “Go to definition”, the language service looks at the TextModel content).

The relationships can be summarized as: **EditorInput ↔ EditorModel ↔ TextModel**. An EditorInput knows how to create or get its EditorModel (via resolve), and an EditorModel either contains a TextModel or is otherwise the source of truth for the editor content. The EditorModel acts as an adaptor that exposes the TextModel to the higher-level workbench and also interfaces with the file system or other backing store.

For contributors working with these pieces, it’s important to follow the patterns: if you implement a new EditorInput type, also implement a corresponding EditorModel that loads the content, and consider implementing the `IWorkingCopy` interface on that model so that VS Code’s dirty-tracking can treat it uniformly (as was done with text files) ([Working Copies · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Working-Copies#:~:text=directly%20onto%20the%20working%20copy,working%20copy%20that%20gets%20registered)) Also, always use the model’s events to react to changes rather than trying to poke at the TextModel directly – for example, listen to `onDidChangeContent` on the EditorModel or TextModel to know when to update UI state, rather than assuming an edit went through. Keeping this separation clear helps maintain consistency: EditorInputs can be reused safely, EditorModels can be cached, and TextModels can be manipulated without concern for UI state.

## Undo/Redo Stack Handling and Change Tracking

Undo/redo in VS Code is handled at the **model level** with support from a global service to coordinate complex cases. Each TextModel maintains its own edit history (undo stack) so that users can undo changes per file in the expected LIFO order of operations. Some key points about how it works internally:

- **Edit Stack per TextModel**: The `TextModel` class has an internal **EditStack** (often called `_commandManager` in code) that records each edit operation ([vscode/src/vs/editor/common/model/textModel.ts at main · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/editor/common/model/textModel.ts#:~:text=private%20readonly%20_commandManager%3A%20EditStack%3B)) When you make an edit, Monaco’s text model logic will create an entry on this stack. Each entry might correspond to a single keystroke or a larger batch (e.g. a multi-line paste) – the stack can group related changes into a single undo step. The TextModel tracks whether an undo or redo is currently in progress (`_isUndoing` / `_isRedoing` flags) to suppress certain events or combine edits correctly ([vscode/src/vs/editor/common/model/textModel.ts at main · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/editor/common/model/textModel.ts#:~:text=private%20readonly%20_commandManager%3A%20EditStack%3B))

- **Versioning**: The TextModel issues a new `versionId` for each content change (monotonically increasing). It also keeps an `_alternativeVersionId` which reflects the state after undo/redo operations ([vscode/src/vs/editor/common/model/textModel.ts at main · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/editor/common/model/textModel.ts#:~:text=%2F)) This is important because an undo will revert the content to an earlier state _without_ decrementing the ever-increasing main version counter; however, `_alternativeVersionId` will match the version of the content as if it were a time-travel counter that can go backward ([vscode/src/vs/editor/common/model/textModel.ts at main · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/editor/common/model/textModel.ts#:~:text=%2F)) In simpler terms, `versionId` tracks forward progress (for change serialization or syncing), whereas the alternative ID helps quickly check if the current content equals a previous state (used in undo/redo logic and for optimizing change events).

- **Global Undo/Redo Service**: VS Code wraps Monaco’s per-model undo stack with the `IUndoRedoService` (in `vs/platform/undoRedo`). This service allows undo/redo across multiple resources when needed. For example, a bulk rename operation might make edits in several files; the UndoRedoService can treat that as a single atomic undo _element_ spanning multiple TextModels. When the user presses Undo, the service will coordinate undoing all those changes together. Each TextModel’s edit stack integrates with this service by registering its edits with a resource identifier, so that the global service knows which file to target for a given undo command. In practice, most single-file edits are handled entirely by the TextModel’s own stack (the global service just delegates to it), but the service is crucial for features like “undo last global workspace edit” or operations that involve non-text resources.

- **Undo Grouping and Merge**: The editing framework also handles the typical editor behavior of coalescing certain operations. For instance, typing `a` then `b` then `c` in quick succession might either be three undo steps or, if appropriate, merged into one. The Monaco editor heuristics (like a time threshold and cursor position check) determine whether subsequent edits join the previous undo stack element or start a new one. Developers contributing to core might not often need to tweak this, but if introducing new types of edits programmatically (via commands or editor contributions), it's wise to consider how you push them onto the stack. VS Code’s UndoRedoService provides methods to push multi-resource edits and also to mark boundaries (for example, some operations can be marked as “redo stops” so that redo won’t combine beyond a certain point).

- **Change Tracking**: Apart from the undo stack itself, VS Code keeps track of the modified state of editors via the **dirty flag** on working copies. As described, any edit sets the working copy dirty. The dirty state is purely a boolean (you can’t have multiple levels of dirty; it’s either saved or not), and it resets on successful save or revert. Internally, the text file EditorModel compares the file content on disk with the model content to know if it’s dirty. Also, when the file is saved or reverted, the edit stack’s baseline is reset (the point to which “undo” would go to reach a clean state is updated). This ensures that after saving, an Undo will reintroduce the edits and mark the model dirty again.

- **File Change Undo**: One interesting aspect is undoing file operations. If you delete a file in VS Code, can you Undo that? Yes – VS Code’s global undo handles not just text edits but also file creations/deletions (these show up as separate entries in the undo stack in the UI, e.g. “Undo Delete File”). The UndoRedoService integrates with the file service to implement that. This is beyond text model, but worth noting as part of the holistic “edit” experience.

For core contributors, the main takeaway is to **use the UndoRedoService** for any operation that should be undoable, especially if it’s not a normal text edit. For typical text editing, Monaco handles the undo stack – avoid trying to manipulate the TextModel’s edit stack manually. Instead, perform edits via the documented methods (like `applyEdits` on ITextModel or editor commands) so that they are tracked. If writing a feature that applies edits to multiple files, batch them through the UndoRedoService so that a single undo can roll all changes back. By respecting these patterns, you ensure that VS Code’s powerful undo/redo (which even allows restoring closed editors in some cases) continues to work uniformly across all contributions.

## Managing Multiple Editors, Editor Groups, and Lifecycle

VS Code supports multiple editors open simultaneously – both in separate split views (editor groups) and hidden in the background (inactive tabs). The core editing framework manages this through the **Editor Group & Editor Service** infrastructure, ensuring a smooth lifecycle for editors:

- **Editor Groups**: An _editor group_ is a container of editors (think of a column of tabs). Each group has its own list of open EditorInputs (tabs), with one active at a time. The **IEditorGroupsService** maintains all groups in the workbench. It knows which group is focused, the arrangement (horizontal splits, etc.), and handles group creation or removal (e.g. when you split an editor or close the last tab in a group). Editor groups have their own events, such as when the active editor within the group changes or when a tab is closed.

- **Opening Editors**: The **EditorService** (workbench’s editor service) is the entry point for opening an editor. Contributors often call `openEditor` with an editor input or a resource. The EditorService will decide which group to open it in (based on provided options or user preferences), will create the EditorInput if it’s not yet created, resolve the EditorModel (loading content), then instantiate the appropriate editor control (e.g. a text editor widget, or a custom editor webview, etc.) in the target group. If the EditorInput is already open in some group, EditorService may choose to reveal that instead of opening a duplicate (depending on the request).

- **Editor Input Reuse**: As mentioned, VS Code avoids duplicating EditorInput instances for the same resource. For example, if “file1.txt” is open in group A and you drag it to group B, group B will also use the _same_ EditorInput object for “file1.txt”. This ensures both groups are editing the same underlying EditorModel/TextModel (which saves memory and keeps their content in sync). The workbench only disposes an EditorInput when it is truly no longer in use by any group ([[Custom Editors API] onDidDispose is not always called on WebviewPanel · Issue #88229 · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/issues/88229#:~:text=%40mjbvz%20it%20is%20intentional%20that,the%20last%20editor%20was%20closed)) Core logic checks all groups when an editor is closed to see if that input is still referenced elsewhere; if yes, it stays alive ([[Custom Editors API] onDidDispose is not always called on WebviewPanel · Issue #88229 · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/issues/88229#:~:text=%40mjbvz%20it%20is%20intentional%20that,the%20last%20editor%20was%20closed)) This behavior means editor state (like selection or scroll position stored in the EditorInput/Model) can persist across groups. It also means extensions or core features can use an EditorInput as a key to identify a document globally.

- **Editor Lifecycle**: The lifecycle of an editor typically goes: **create EditorInput** → **resolve EditorModel** → **create editor control (attach TextModel)** → _user interacts, possibly makes changes_ → **dispose editor control (on close or group change)** → **dispose EditorInput/EditorModel** (when no longer needed). There are some nuances:

  - VS Code often keeps EditorModels alive even after an editor tab is closed, in case the user reopens it (this is an in-memory cache with a timeout/limit).
  - If an editor is closed and dirty, VS Code will keep it open in memory (and in the UI it actually doesn’t fully close – it shows as a closed tab that can be recovered on next restart via backups). The model won’t be disposed until the user either saves or explicitly abandons the changes (revert).
  - When an EditorModel is disposed, it should free the TextModel. The WorkingCopyService will unregister it, so it’s no longer tracked as a dirty working copy. If the user reopens that file, a fresh model will be loaded from disk or backup.

- **Switching Active Editors**: The workbench emits an event when the active editor changes (either because a different tab was selected or focus moved to a different group). Internally, `EditorService.onDidActiveEditorChange` is fired whenever the global active editor changes (which could be a change in active group or a tab change) ([vscode/src/vs/workbench/services/editor/browser/editorService.ts at main · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/workbench/services/editor/browser/editorService.ts#:~:text=this)) This is what triggers, for example, the visible editors in the explorer to highlight, or the extension API event `onDidChangeActiveTextEditor`. There are also events per group for when the group’s active editor switches, and for when editors open or close in a group.

- **Editor Groups Lifecycle**: Groups themselves can be created/destroyed. When you split a group, all EditorInputs in the original might be duplicated or some moved – the exact behavior depends on the split action (VS Code has commands to split and duplicate the active editor to the new group). The EditorGroupsService will create a new group object and insert the EditorInput (potentially calling EditorInput.copy() if defined, or just reusing it). When groups merge or an editor is dragged between groups, references are updated accordingly. For core contributors, if introducing new ways to manipulate groups or new editor types, it’s important to utilize EditorService and EditorGroupsService APIs to do so, as they ensure this reference counting and event firing is handled.

- **Editor Disposal**: When the last group using an EditorInput is closed, the EditorInput is disposed. Disposal will fire an `onDispose` event on the EditorInput (if anyone is listening). The EditorModel it holds onto will typically also be disposed at that point (unless another open editor or some extension is holding onto it via a different route). The EditorModel’s disposal triggers its `onWillDispose` ([CoCalc -- editorModel.ts](https://cocalc.com/github/microsoft/vscode/blob/main/src/vs/workbench/common/editor/editorModel.ts#:~:text=15)) and it will free the TextModel. Contributors should be cautious to clean up any resources when an editor is disposed. If you add any custom EditorInput or EditorModel subclass, ensure to implement proper disposal (e.g. unregister any listeners, dispose any caches) by overriding `dispose()`.

In practice, much of the heavy lifting of multiple editor management is handled by the existing services. To contribute effectively, use those services rather than reinventing management. For example, to open a custom editor programmatically, call `editorService.openEditor` with the appropriate input instead of manually instantiating an editor. If adding a new editor type (say a custom document type in core), tie it into the working copy and editor services so that it benefits from hot-exit, dirty tracking, and consistent reuse semantics. And always consider the case of multiple views of the same data – e.g., two editors showing the same model – and leverage VS Code’s reuse of EditorInputs to keep them in sync.

## Internal Event System Related to Editing

Events are a backbone of VS Code’s architecture – almost every part of the editor emits events to signal state changes, and these events propagate through the system to update UI and drive features. In the editing framework, key events include:

- **TextModel Events**: The Monaco TextModel emits a variety of events:

  - `onDidChangeContent` – Fires whenever the text content changes (with details about the changes) ([vscode/src/vs/editor/common/model/textModel.ts at main · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/editor/common/model/textModel.ts#:~:text=private%20readonly%20_eventEmitter%3A%20DidChangeContentEmitter%20%3D,register%28new%20DidChangeContentEmitter)) Core logic (like dirty tracking) and extension host (via the VS Code API’s onDidChangeTextDocument) listen to this.
  - `onDidChangeDecorations` – Fires when decorations on the model are changed ([vscode/src/vs/editor/common/model/textModel.ts at main · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/editor/common/model/textModel.ts#:~:text=public%20readonly%20onDidChangeDecorations%3A%20Event,event)) (for instance, adding or removing a marker/diagnostic causes this). It allows parts of the UI like the overview ruler or minimap to know they need to repaint.
  - `onDidChangeLanguage` / `onDidChangeLanguageConfiguration` – Fires when the model’s language mode or settings (like tab size) change ([vscode/src/vs/editor/common/model/textModel.ts at main · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/editor/common/model/textModel.ts#:~:text=public%20get%20onDidChangeLanguage%28%29%20,onDidChangeLanguage%3B)) This can happen if you manually change the language of a file or if an extension like VS Code’s built-in language detection updates it. Such events prompt retokenization or reapplication of language-specific settings.
  - `onDidChangeTokens` – Fires when the syntax highlighting tokens for the model are updated ([vscode/src/vs/editor/common/model/textModel.ts at main · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/editor/common/model/textModel.ts#:~:text=this._tokenizationTextModelPart.onDidChangeLanguageConfiguration%3B%20)) (e.g. after (re)tokenizing the text as you type). This is used to repaint the editor with new syntax colors or semantic highlighting.
  - There are others, like `onWillSave` and `onDidSave` events on the text file model (which fire right before saving and after saving a file), and `onDidChangeDirty` on working copies (when a model becomes dirty or clean).

- **Editor (UI) Events**: The editor widget (ICodeEditor) also emits events, such as:

  - Cursor position changed, selection changed – used for features like highlighting the matching bracket or updating line/column status.
  - Editor focus gained/lost – used to hide or show certain UI elements.
  - Layout or scroll changed – used to adjust decorations or reveal ranges.
  - These are more transient UI events and are typically handled within the editor or by editor contributions (like the cursor position change is handled by the bracket matching contribution to draw a highlight).

- **Workbench Editor Events**: At the workbench level, events include:

  - `onDidOpenEditor` / `onDidCloseEditor` – when an editor (EditorInput) is opened or closed in a group. The workbench emits these so that, for example, the MRU (most-recently-used) list updates, or the explorer knows a file is no longer open and can remove decorations on it.
  - `onDidChangeActiveEditor` – when the active editor (globally) changes, as mentioned earlier. This event is fired by EditorService whenever you switch to a different editor or pane ([vscode/src/vs/workbench/services/editor/browser/editorService.ts at main · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/workbench/services/editor/browser/editorService.ts#:~:text=this)) The VS Code extension API’s `window.onDidChangeActiveTextEditor` is hooked to this.
  - `onDidChangeVisibleTextEditors` – when the set of visible editors changes (opening, closing, or moving editors triggers this). This corresponds to extension API and helps with things like live share or any feature that needs to know all open editors.
  - EditorGroupsService also has events like `onDidChangeActiveGroup` (when focus changes from one split to another) and `onDidLayoutChange` (if the splits rearrange).

- **Event Propagation and Handling**: VS Code uses a lightweight, efficient event library (`vs/base/common/event.ts`) which provides an `Emitter` class. Components create emitters and expose an `Event` for others to subscribe. Handlers (listeners) are disposed automatically when, for instance, an editor is closed, to prevent leaks. For example, the TextModel has an internal `DidChangeContentEmitter` and the `onDidChangeContent` property is a Event you can subscribe to ([vscode/src/vs/editor/common/model/textModel.ts at main · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/editor/common/model/textModel.ts#:~:text=private%20readonly%20_eventEmitter%3A%20DidChangeContentEmitter%20%3D,register%28new%20DidChangeContentEmitter)) Subscribers get an `IDisposable` they can dispose if needed (though disposing the model or the listener’s context usually cleans it up too). This event system is synchronous by default (listeners are called immediately within the emitting function) unless documented otherwise.

- **Extension API Bridge**: Many internal events are bridged to the extension host via the **ExtHost**/**MainThread** communication. For instance, when a TextModel’s content changes, VS Code will, after doing its internal work, notify the extension host (on a debounce or schedule) that a TextDocument changed, triggering extension `onDidChangeTextDocument` events. This is mostly transparent to core contributors, but it's good to know that an event on the model can have far-reaching effects (possibly causing extension code to run, which might in turn call more VS Code API).

For developers contributing to VS Code’s core, the event system means **you should hook into existing events rather than polling for changes**, and likewise emit events for any state changes your code introduces. If you create a new model type or editor, fire the standard events (`onDidChangeContent`, `onDidChangeDirty`, etc.) so that things like autosave, the status bar, and extensions all respond correctly. Use the `Emitter` class to create events; make sure to dispose of emitters when the object is disposed. Also, be mindful of performance – if your feature needs to react to `onDidChangeContent`, ensure the handler is efficient (possibly use debouncing if doing something heavy on each keystroke). The event-driven design is what lets VS Code remain responsive and modular, as features only wake up when relevant changes happen.

## Integration of Language Services and Decorations with the Core Editor

One of VS Code’s strengths is its rich language support – things like IntelliSense, diagnostics (errors/warnings), code lenses, inline hints, semantic highlighting, etc. These are largely provided by **language services** often running in extensions (or built-in extension processes). The core editor framework provides the hooks and infrastructure to display these results and to let them react to editing events:

- **Tokenization and Syntax Highlighting**: VS Code uses a combination of TextMate grammars (for classic syntax highlighting, contributed by extensions or built-in for many languages) and semantic token providers (often from language servers) to colorize code. The **TextModel** has a tokenization subsystem that stores token information for each line. When you open a file or change language, the model is (re)tokenized – this can happen incrementally as you scroll. The model emits `onDidChangeTokens` when tokenization data for some range is available ([vscode/src/vs/editor/common/model/textModel.ts at main · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/editor/common/model/textModel.ts#:~:text=this._tokenizationTextModelPart.onDidChangeLanguageConfiguration%3B%20)) prompting the editor to repaint those lines with new colors. Extensions that provide grammars register them, and VS Code’s text model will invoke those to compute tokens. Semantic tokens (for semantic highlighting) are requested via a separate mechanism but ultimately also apply decorations/tokens to the model. As a contributor, you typically wouldn’t modify tokenization core logic unless working on the languages subsystem, but it’s useful to know that **language identifier changes** on a model (like switching a file from plain text to JavaScript) will trigger reloading of tokens and possibly reconfiguration of the editor (e.g. bracket pairs, indentation rules – these come from language configuration).

- **Diagnostics (Errors & Warnings)**: Diagnostics are published by language extensions or tasks and are fed into VS Code’s **Marker Service**. The Marker Service (in `vs/platform/markers`) keeps track of all known errors/warnings per resource (file). The editor listens to marker changes for the files it has open. When diagnostics for a file change (say, you fixed an error, so the error is removed), the Marker Service triggers an update, and the editor core uses that to add or remove **decorations** on the TextModel. Specifically, an error or warning is shown as a red or yellow squiggly underline – these are implemented as **model decorations** with specific styling. The Monaco editor API provides `deltaDecorations` to add or remove decorations on a model given ranges. VS Code uses an owner ID for marker decorations such that when markers update, it calls something like `setModelMarkers` (Monaco API) which under the hood adjusts those decorations. The TextModel’s `onDidChangeDecorations` event will fire when these are applied ([vscode/src/vs/editor/common/model/textModel.ts at main · microsoft/vscode · GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/editor/common/model/textModel.ts#:~:text=public%20readonly%20onDidChangeDecorations%3A%20Event,event)) which can prompt a re-render of the glyph margin (where the error lightbulb icon might appear) or the overview ruler. From a core perspective, if you’re handling diagnostics or other automated decorations, use the services like `IMarkerService` to set markers rather than manipulating decorations directly, so that the consistency (and potential extension overrides) remain intact.

- **Language Features (Code Actions, Completion, etc.)**: Features like code completion, parameter hints, and quick fixes are provided by extensions but orchestrated by core. For example, when the user requests completion (like triggering Ctrl+Space or as they type a trigger character), the core editor fires an internal event or command that is handled by the **Suggest Controller** (an editor contribution in core). That controller asks the VS Code extension host for suggestions (via the completion provider API). When results come back, the controller displays them using core components (the suggestion widget). Similar flows exist for hover, signature help, code actions (lightbulb), references, etc. Each of these is implemented as an **editor contribution** (often located in `vs/editor/contrib/...` in the source). They listen to editor events (e.g. cursor change, or typing certain characters) and call into the language feature registries. For contributors, if working on these areas, it’s key to utilize the existing registries and event hooks – for example, if implementing a new kind of inline hint, one would likely add a new type of model decoration or an overlay widget, and hook it up to extension-provided data.

- **Decorations API**: Beyond diagnostics, VS Code core and extensions use decorations for many purposes: highlighting the active line, showing matching search results, indent guides, bracket match highlighting, inline suggestions (ghost text), etc. The editor’s decoration API is quite flexible. Core features typically register an **`IEditorContribution`** that manages a set of decorations. For instance, the Bracket Matching contribution listens on cursor movement; when the cursor is on or next to a bracket, it finds the matching bracket and uses `editor.deltaDecorations` to add a highlight decoration to those two bracket characters. These decorations are given a style (defined in CSS or via the theme) such as a background color or underline. Another example: the **indent guide** contribution uses decorations that apply a vertical line rendering in the margin area for each indent level – these are updated when the document or indentation changes. The internal event system (content change, cursor change) informs these contributions when to recalc and update decorations.

- **Semantic and Inlay Hints**: Newer editor features like _inlay hints_ (parameter names inline in code) or _semantic highlights_ are also integrated via model decorations. The language server provides data (e.g. “show parameter `x:` ghost text at this position”) and core will create a decoration at that range with a custom rendering (like greyed text for the hint). In the case of semantic coloring, the data from the language server is applied as special classifications on tokens which the rendering then picks up.

The core principle in integrating language services is that **extensions provide the data, core manages the presentation**. So core code (in the editor or workbench) listens for changes (like diagnostics arriving, or completion requested) and then uses the editor’s capabilities (widgets, decorations, markers) to reflect that. For contributors, ensure that any core feature you work on stays in sync with the model’s state and uses the correct channels for updates. For instance, if you write a new diagnostic source in core (just as an example), you’d add markers via `MarkerService` so that all existing machinery (Problem panel, gutter decorations, etc.) picks it up, rather than inventing a parallel mechanism. Similarly, any new kind of decoration should ideally be implemented as an editor contribution or integrated with the model’s decoration system, so that it benefits from the efficient painting and diffing Monaco provides.

## Significant Internal APIs and Subsystems for Core Contributions

Working on VS Code’s core requires familiarity with certain key services and API contracts that glue the editor experience together. Here is a rundown of some important ones relevant to the editing framework:

- **ITextModelService / IModelService**: Responsible for creating and managing text models. In VS Code, you typically don’t create a TextModel by calling the constructor directly; instead, you ask `ITextModelService` to resolve a resource to a text model (which handles caching and reuse). The model service ensures that if the same file is opened multiple times, you get the same TextModel instance. It’s also involved in decorating models with language-specific configurations (like tab size from settings, detect indentation, etc.).

- **ITextFileService & TextFileEditorModel**: Deals with reading/writing files from disk or other sources, specifically for text files. The TextFileEditorModel (accessed via TextFileService) implements loading from the file system, saving (including handling Save Conflict resolution, etc.), and even certain operations like “Save As” or reverting to content on disk. It implements `IWorkingCopy` ([Working Copies · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Working-Copies#:~:text=directly%20onto%20the%20working%20copy,working%20copy%20that%20gets%20registered)) and interacts with the WorkingCopyService for dirty tracking and backups. If contributing to file save/revert logic, this is the area to understand. The service also handles _auto-save_ (it has a schedule to periodically save dirty models if auto-save is enabled).

- **IWorkingCopyService**: As described earlier, a centralized service to register anything that is editable and dirty-able. When you open a new working copy (like a custom editor document), you register it here so that VS Code’s generic commands (Save, Save All, Revert All) and the shutdown backup logic will include it. For core contributions, if you introduce a new editor model type, you should register it as a working copy. The service provides events for when any working copy becomes dirty or saves – the “dirty files” UI in VS Code (the dot on the close button, the list in the backups on restart) all rely on this. It also can enumerate all dirty working copies, which is used when the user presses “Save All”, etc.

- **IEditorService & IEditorGroupsService**: These are the high-level APIs to open editors and manage groups. `IEditorService.openEditor` is heavily used in the code whenever something needs to present a document to the user (for example, clicking a search result, or a debugger “open file” request). It takes care of group logic and uses the registered **editor resolvers** to decide which editor to use (for instance, if a file can be opened in a custom editor or the default text editor). `IEditorGroupsService` lets you iterate or command the arrangement of groups (like creating a new group or moving an editor to another group). If adding commands or features that manipulate editor layout or open files, these services are your friend.

- **EditorInput and EditorModel subclasses**: Understanding existing subclasses is useful. For example, `UntitledTextEditorInput` (and model) for unsaved new files, `DiffEditorInput` which contains two other EditorInputs for the sides of the diff, `NotebookEditorInput` for notebooks, etc. Each of these might bring its own model (notebooks have a complex model). They often override methods like `resolve()` to load content. They might also override things like how the EditorInput shows up in tab labels or how it can be serialized for backups. When contributing, if you need a new EditorInput type, mimic the structure of these classes and ensure to integrate with the services (e.g., register a handler with `IWorkingCopyEditorService` if needed so the workbench knows how to reopen it from a backup ([Working Copies · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Working-Copies#:~:text=In%20most%20ways%2C%20working%20copies,IWorkingCopyEditorService)) ([Working Copies · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Working-Copies#:~:text=When%20you%20introduce%20a%20working,registerHandler)) .

- **IMarkerService and IDecorationsService**: The MarkerService, as mentioned, keeps track of diagnostics (and other markers like TODO comments perhaps). The DecorationsService is a related service that can merge multiple decoration data sources. For example, SCM (git) might provide decorations (like gutter indicators for modified lines) and an extension might provide inline color decorators for color codes – these funnel through a service that coordinates them so they don’t conflict and are efficiently rendered. If core needs to add a new kind of decoration or marker (e.g., let's say a new type of warning or a special highlight for certain search results), using these services ensures they appear in the UI consistently.

- **ICommandService and Keybindings**: While not editing-specific, if your contribution adds an editor command (like a new action when editing), you’ll interact with the command service and keybinding service. Registering commands (with `registerCommand`) and keybindings (in `package.json` or dynamically) allows users to invoke your feature. Many editor features are also accessible via command palette, so core contributions often come with new commands.

- **IEditorContribution (Monaco Editor contributions)**: On a more code-editor-specific note, Monaco allows adding contributions to the editor instance. Many core features like bracket matching, code folding, find/replace widget, etc., are implemented as classes that implement `IEditorContribution`. They are registered via the editor extension registry so that every new editor instantiation will create those contribution objects, attaching their behavior. For example, the **FindController** adds the capability to find text in the editor (listening for Ctrl+F and showing the UI). As a contributor, if you want to enhance the core editor behavior (not just via the extension API, but truly in the core), you might do so by creating an editor contribution. This way your code runs for each editor instance and can maintain editor-specific state, and it will get disposed automatically when the editor is disposed. The interface is simple (basically just a dispose method), but the pattern is important.

- **Services for Language Features**: If working on how language features integrate, there are various registries: `languages.registerXXXProvider` on the extension host side corresponds to `LanguageFeaturesService` or similar in the renderer. For example, completions are collected via a Suggest Model that queries all providers. Hover, definitions, references each have their coordinator in core. Understanding these might require digging into `vs/editor/contrib` source. For instance, quick fixes (code actions) are managed by a CodeActionController in the editor and a `CodeActionModel` that listens to cursor position and diagnostics.

In conclusion, contributing to VS Code’s core editing framework means working with a **well-abstracted system**. You rarely need to manipulate DOM or redraw things manually – instead, you interact with models, services, and let the existing systems propagate changes. Keep changes **layered**: the editor/editorModel for content, the workbench for window management, and services connecting them. By respecting the existing abstractions (EditorInput vs Model, working copy, etc.) and using the provided service APIs, you can extend or modify the editor in a way that stays consistent with the rest of VS Code. Always test your changes with multiple editors open, with different file types, and with extension features (like test that undo/redo still works, that saving still triggers, etc.), because the editor framework is interconnected. With a good grasp of these components and APIs, you’ll be able to contribute effectively to VS Code’s core editing experience.
