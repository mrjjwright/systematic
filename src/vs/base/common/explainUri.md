Got it! I will conduct detailed research within the VSCode GitHub codebase to trace how VSCode handles file system resources, converts them to URIs, and passes them across the main thread and extension APIs. This will cover:

- How file paths are mapped to URIs
- Serialization and deserialization of URIs
- How URIs are passed between the renderer (main thread) and extensions
- Relevant APIs and modules responsible for URI management

I'll get back to you with a structured breakdown of the findings.

# Managing URIs and File Paths in VSCode

VS Code uses a unified **URI** system to represent file paths and other resources. Internally, file system paths are converted into URIs and manipulated through URI utilities rather than raw strings. This ensures consistent handling across platforms (Windows, Linux, macOS) and between VS Code’s processes (main renderer, extension host, etc.). Below, we explore how VS Code maps file paths to URIs, which modules/functions handle these conversions, how URIs are serialized across process boundaries, and how they are exposed to extensions via the API. We also highlight internal utilities for tracking file resources and resolving URIs.

## Mapping File Paths to URIs

**File paths** (e.g. `C:\Users\Name\file.txt` or `/home/name/file.txt`) are turned into VS Code URIs using the static factory methods on VS Code’s URI class. The key method is `URI.file(path)`, which creates a URI with the **`file`** scheme from a filesystem path. This method normalizes the input path to a standard URI format:

- **Path Separators:** On Windows, backslashes (`\`) in the path are replaced with forward slashes, because VS Code URIs consistently use forward slashes in the path component ([vscode/src/vs/base/common/uri.ts at main - GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/base/common/uri.ts#:~:text=,r.txt%20if)). (On other OSes, backslashes can be valid characters in filenames, so they are not transformed.)
- **UNC Paths:** Network paths (UNC) like `\\server\share\folder` are recognized and converted to `file://server/share/folder` URIs. In such cases, the “server” portion becomes the URI’s authority, and the rest becomes the path. The `URI.file` implementation checks for paths starting with `//` (after normalization) to detect UNC paths ([vscode/src/vs/base/common/uri.ts at main - GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/base/common/uri.ts#:~:text=,r.txt%20if)).
- **Drive Letters:** Windows drive letters are normalized to lowercase in the URI. For example, `"C:\\Path\\File.txt"` becomes a URI with path `/c:/Path/File.txt` (drive letter `c` lowercased) ([Uri | monaco-editor](https://blutorange.github.io/primefaces-monaco/typedoc/classes/monaco.uri.html#:~:text=Uri%20%7C%20monaco,fsPath%20%29)). This ensures that URIs pointing to the same file are treated equally even if the drive letter’s case differs. The URI’s `fsPath` (see below) will use the platform’s casing and separators.
- **Ensuring Absolute Paths:** If the given path isn’t already absolute, `URI.file` will prepend a slash. VS Code URIs for file paths are always absolute (the path in a `file` URI always begins with `/`). For example, on Windows a root like `C:\` becomes `file:///c:/` in URI form.

**Example:** Calling `URI.file('C:\\Users\\Alice\\project\\README.md')` returns a URI object with `scheme: "file"`, `authority: ""` (empty for local files), and `path: "/c:/Users/Alice/project/README.md"` ([Uri | monaco-editor](https://blutorange.github.io/primefaces-monaco/typedoc/classes/monaco.uri.html#:~:text=Uri%20%7C%20monaco,fsPath%20%29)). Internal code comments note this normalization behavior (forward slashes, drive-letter casing, etc.) ([vscode/src/vs/base/common/uri.ts at main - GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/base/common/uri.ts#:~:text=,r.txt%20if)). The resulting URI’s `fsPath` property would produce the normalized native file path (`C:\Users\Alice\project\README.md` with a lowercase drive letter) when needed.

## Core URI Class and Conversion Functions

VS Code defines a robust **URI class** in the core (`src/vs/base/common/uri.ts`) that handles parsing and formatting of URIs. This is the same implementation used by the VS Code extension API and by internal code. Key functions and usage include:

- **`URI.parse(string)`** – Parse a URI from a string. This handles full URI strings like `"https://example.com/path?query#frag"` or `"file:///c:/path"` by splitting out the scheme, authority, path, query, and fragment components. It returns a `URI` object. (If the string is missing a scheme and strict mode is used, it may throw – e.g. they added a `strict` option to ensure a scheme exists ([add Uri.parse(value, strict) so that missing scheme throw ...](https://git.lance1416.com/Microsoft/vscode/commit/c15559789fcab65f8ea989ee7d5dfdad6e2bdec0#:~:text=add%20Uri,value%3A%20string%2C%20_strict%3F%3A%20boolean%29%3A%20Uri)).) In practice, `URI.parse` is used for known URI strings or when reading stored URIs.
- **`URI.file(path)`** – Create a file URI from a filesystem path. As described above, this static method ensures the path is properly normalized for a `file:` URI (handles slashes and drive letters) ([vscode/src/vs/base/common/uri.ts at main - GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/base/common/uri.ts#:~:text=,r.txt%20if)) ([Uri | monaco-editor](https://blutorange.github.io/primefaces-monaco/typedoc/classes/monaco.uri.html#:~:text=Uri%20%7C%20monaco,fsPath%20%29)). It’s commonly used when VS Code needs to convert a local file path (from the OS or user input) into a URI object.
- **`URI.from(components)`** – Build a URI from discrete components. This is a convenience for cases where you have separate `scheme`, `authority`, `path`, `query`, `fragment` fields (often represented by the `UriComponents` interface). For example, `URI.from({ scheme: 'file', path: '/c:/project/file.txt' })` creates the corresponding URI. Internally, `URI.from` simply invokes the URI constructor with those parts. In fact, the implementation calls `new Uri(...)` with the provided components ([vscode/src/vs/base/common/uri.ts at main - GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/base/common/uri.ts#:~:text=vscode%2Fsrc%2Fvs%2Fbase%2Fcommon%2Furi.ts%20at%20main%20,path)). It can also accept an existing `UriComponents` object (like one that was serialized earlier).
- **`URI.toString()`** – Produce the string form of the URI. This is used whenever a URI needs to be serialized or displayed. It includes the scheme, authority (if any), and path, and will encode characters as needed to produce a valid URI string. (For file URIs, this typically yields a `file:///` URL form.)
- **`URI.fsPath`** – Get the file system path string from a URI (if applicable). For `file` scheme URIs, `fsPath` gives the native file path. The URI class overrides this getter to compute the correct path: on Windows it converts the forward slashes back to `\` and handles UNC or drive letter formatting ([Uri | monaco-editor](https://blutorange.github.io/primefaces-monaco/typedoc/classes/monaco.uri.html#:~:text=Uri%20%7C%20monaco,fsPath%20%29)). VS Code caches this value for performance, since it may be accessed frequently (the implementation uses an internal `_fsPath` field to store the computed result) ([https://git.lance1416.com/Microsoft/vscode/commit/...](https://git.lance1416.com/Microsoft/vscode/commit/90efeb4f2dc41827b382c8bb5da1c3abfff9459f.patch#:~:text=...%20with%20vscode.Uri%20%28API%29.%20,null%20%3D%20null)). Non-file URIs (e.g. `http:` or `git:`) may return a path that is just the URI’s path component (or an empty string) since `fsPath` mainly makes sense for file system locations.
- **`URI.with({...})`** – Create a copy of a URI with some parts changed (e.g. changing just the `query` or `fragment`). This is useful to tweak URIs without parsing and reassembling them manually. It returns a new `URI` instance.

Under the hood, the **`URI` class** is implemented in TypeScript (and also published as the `vscode-uri` npm package) and follows the standard RFC 3986 for parsing. VS Code’s source defines `URI` in a way that the extension API’s `vscode.Uri` is effectively the same class. In fact, the extension API `Uri` is implemented by extending the core `URI` class. A recent refactoring replaced an internal `CachingURI` with a unified class `Uri` that extends `URI` ([https://git.lance1416.com/Microsoft/vscode/commit/...](https://git.lance1416.com/Microsoft/vscode/commit/90efeb4f2dc41827b382c8bb5da1c3abfff9459f.patch#:~:text=...%20with%20vscode.Uri%20%28API%29.%20,null%20%3D%20null)) (this class holds cached `_formatted` and `_fsPath` values for efficiency). This means the **internal and external (API) representations of URIs share the same logic** for parsing and normalization, ensuring consistency.

## File System Resource Resolution and Tracking

Throughout VS Code’s codebase, URIs are the primary way to refer to resources on the file system (and other virtual resources). The **file service** and related components use URIs for identifying files and folders:

- VS Code’s `IFileService` (in `vs/platform/files/common/files.ts`) offers methods like `watch(resource: URI)`, `resolve(resource: URI)`, `readFile(resource: URI)`, etc. All of these APIs expect a `URI` to locate the file ([File watcher: have a `createWatcher(resource: URI)` API for ... - GitHub](https://github.com/microsoft/vscode/issues/126809#:~:text=GitHub%20github,IDisposable%3B%20onDidFilesChange%3A%20Event)). This design allows VS Code to work with not only local disk files (`file:` URIs) but also remote files or special schemes (via extension file system providers) in a uniform way. For example, watching a file changes or reading contents is always done via a URI, and the file service will delegate to the appropriate provider based on the URI’s scheme.
- **Resource Resolution:** When VS Code needs to resolve a user-provided path (say from a command-line argument, a workspace setting, etc.), it will convert that path to a `URI` (often with `URI.file`) before proceeding. This ensures the path is in the correct form and allows VS Code to use its URI-based infrastructure. For instance, if a configuration points to `"../someFolder"`, VS Code might resolve it relative to the workspace folder URI.
- **File System Watching:** The file service’s `watch()` takes a URI to set up a watcher. When files change, VS Code raises events with URIs. The event `onDidFilesChange` carries a `FileChangesEvent` which contains the URIs of changed files. Internally, URIs make it easy to compare and normalize paths (for example, there are utilities to compare URIs with case insensitivity on Windows). VS Code’s `resources.ts` module provides helper functions like `basename(uri)`, `dirname(uri)`, and `joinPath(baseUri, pathFragment)` to manipulate URIs as if they were file paths. These helpers respect the URI’s semantics (e.g. not changing the casing of drive letters improperly) ([resources.join & normalize must not change windows drive letter ...](https://git.lance1416.com/Microsoft/vscode/commit/2d9093bcf215189f40eafb2e301db91d0d19a8d5?style=split&whitespace=show-all&show-outdated=#:~:text=resources,export%20function%20joinPath)).
- **Cross-Platform Concerns:** Since the VSCode **renderer process runs in a Node-less environment** (or in web scenarios), it cannot use Node’s `path` module directly. Instead, VS Code relies on the URI utilities and its own path helpers for tasks like joining paths, determining relative paths, etc. For example, `joinPath()` is used to append segments to a URI’s path, and it will ensure the proper separators are used and relative segments resolved. The implementation of `joinPath` was carefully designed not to alter the case of Windows drive letters ([resources.join & normalize must not change windows drive letter ...](https://git.lance1416.com/Microsoft/vscode/commit/2d9093bcf215189f40eafb2e301db91d0d19a8d5?style=split&whitespace=show-all&show-outdated=#:~:text=resources,export%20function%20joinPath)) (preserving the normalization done at URI creation).

By using URIs everywhere for file tracking, VS Code can easily work with abstract resources. Whether a file is on the local disk, on a remote SSH filesystem, or an in-memory `untitled:` file, it’s identified by a URI. The file service knows how to route these URIs to the correct handlers. This abstraction is crucial for VS Code’s multi-root workspaces and remote development features.

## URI Serialization Across the Main Thread Boundary

VS Code is split into processes/threads: the **renderer** (running the workbench UI, which can be a web context) and the **extension host** (Node.js process, or a web worker in web extensions). URIs often need to be sent across the boundary between these contexts. However, you can’t directly send class instances (like a `URI` object) through VS Code’s IPC/RPC channel – instead, VS Code **serializes URIs** into plain objects and reconstitutes them on the other side.

When a URI is sent from one side to the other (e.g. an extension returns a `Uri` to the main thread, or the main thread passes a `Uri` to an extension callback), VS Code uses a structured object called **`UriComponents`**. This is typically a simple object with properties `{ scheme, authority, path, query, fragment }` that describe the URI. Additionally, VS Code tags such objects with a marker to identify them as URIs during marshaling:

- The serialized form of a URI includes a special field (often `$mid`) to indicate its type. For URIs, VS Code sets `$mid: MarshalledId.Uri` (where `MarshalledId.Uri` is an internal numeric code for “this is a URI”). It may also include some cached conveniences like `fsPath` or a fully formatted string (`external`) for efficiency ([fix `UriComponents` typings, add `isUriComponents`, add doc to ...](https://git.lance1416.com/Microsoft/vscode/commit/2b98fc4218d010c441df83a8bd5a417c9a8cc4ff#:~:text=class%20Uri%20extends%20URI%20,)), but these are optional and used as hints.
- On the receiving end, VS Code detects this object as a URI (via the `$mid` identifier) and **revives** it into a proper `URI` instance. There is a helper `URI.revive(data)` that takes either a `UriComponents` object or an actual `URI` and returns a `URI` object. If the input is already a `URI`, it just returns it; if it’s a plain object, it reconstructs a new `URI` from those components ([vscode-uri@3.0.8 - jsDocs.io](https://www.jsdocs.io/package/vscode-uri#:~:text=method%20revive.%20static%20revive%3A%20,UriComponents%29%3A%20URI)). In the code, during RPC message handling, you can see that if an object with `$mid` of type URI is encountered, they call `URI.revive(obj)` to deserialize it ([vscode/src/vs/base/common/marshalling.ts at main · microsoft ...](https://github.com/Microsoft/vscode/blob/master/src/vs/base/common/marshalling.ts#:~:text=,any%3E)).
- **Example – Marshalling:** In the marshalling logic (`src/vs/base/common/marshalling.ts`), the code checks for known types. For URIs, it does:
  ```ts
  case MarshalledId.Uri:
      return URI.revive(obj);
  ```
  This converts the raw object back into a `URI` instance on the receiving side ([vscode/src/vs/base/common/marshalling.ts at main · microsoft ...](https://github.com/Microsoft/vscode/blob/master/src/vs/base/common/marshalling.ts#:~:text=,any%3E)).

Because URIs are passed as structured JSON, the **renderer (which has no Node)** can still receive a file URI from the extension host and treat it correctly. It doesn’t need Node’s path handling – it just uses `URI` methods. The URI is rehydrated in the renderer and can be used in API calls or UI logic just like any other `URI` instance.

**Serialization details:** The `URI` class defines a custom `toJSON()` method that produces the `UriComponents` shape (plus the `$mid`). This means when a `URI` is sent via VS Code’s proxy RPC, it automatically turns into the right JSON. The presence of `$mid` is a version marker that helps ensure compatibility. VS Code’s implementation uses this to trust that an object is a properly structured URI. It may include an `external` field which is the URI’s full string (output of `toString()`), and an `fsPath` field (the file path) ([fix `UriComponents` typings, add `isUriComponents`, add doc to ...](https://git.lance1416.com/Microsoft/vscode/commit/2b98fc4218d010c441df83a8bd5a417c9a8cc4ff#:~:text=class%20Uri%20extends%20URI%20,)). These saved values can be used on the other side to avoid recomputing the string or path. For example, if `this._formatted` was cached (the URI string), `toJSON()` adds it as `external` ([fix `UriComponents` typings, add `isUriComponents`, add doc to ...](https://git.lance1416.com/Microsoft/vscode/commit/2b98fc4218d010c441df83a8bd5a417c9a8cc4ff#:~:text=class%20Uri%20extends%20URI%20,)). The receiving side might then simply use that string if needed, or just reconstruct from components.

In summary, whenever URIs cross the main<->extension boundary, they are **serialized to plain objects** and then **deserialized back into `URI` objects**. This allows seamless passing of complex types like URIs without exposing the actual class instances over the wire.

## URIs in the Extension API

From an extension author’s perspective, VS Code’s **`vscode.Uri`** behaves like a normal class for URIs. Internally, this is backed by the same implementation described above. Some key points about URIs in the extension API and how they interact with the VS Code internals:

- **Creating URIs in Extensions:** Extensions use `vscode.Uri.file(path)` to create file URIs from file system paths (just as internal code does) and `vscode.Uri.parse(string)` to parse URI strings. These call into the underlying URI logic (the extension’s `Uri` class inherits the core implementation). So when an extension calls `vscode.Uri.file('/some/path')`, it goes through the same normalization (e.g. Windows drive letter lower-casing, etc.) and returns a `Uri` object that the extension can use ([Uri | monaco-editor](https://blutorange.github.io/primefaces-monaco/typedoc/classes/monaco.uri.html#:~:text=Uri%20%7C%20monaco,fsPath%20%29)).
- **Extension API `Uri` Class:** The `vscode.Uri` class is essentially identical to VS Code’s internal `URI`. The extension host defines it in its API layer (in `extHostTypes.ts`) by extending the core class. For example, `class Uri extends URI { ... }` is used to ensure any extra caching or to string tagging is consistent ([https://git.lance1416.com/Microsoft/vscode/commit/...](https://git.lance1416.com/Microsoft/vscode/commit/90efeb4f2dc41827b382c8bb5da1c3abfff9459f.patch#:~:text=...%20with%20vscode.Uri%20%28API%29.%20,null%20%3D%20null)). This means that properties like `scheme`, `path`, `fsPath`, and methods like `toString()` work the same in extensions as they do in the core.
- **Passing URIs to VS Code (from Extension):** When an extension calls an VS Code API function that takes a `Uri` (for instance, `workspace.openTextDocument(uri)` or `window.showTextDocument(uri)`), the extension host will send that URI over to the main thread via RPC. As explained, the `Uri` gets serialized to `UriComponents`. On the main side, it’s revived to a `URI` and used to, say, open the document. The extension author doesn’t see this serialization – it’s transparent. They just pass a `Uri` object and it works. For example, if an extension calls `vscode.window.showTextDocument(someUri)`, internally the extension host calls a proxy method like `$tryShowTextDocument(UriComponents)` to the main thread. The main thread revives it to a URI and opens the editor for that resource.
- **Receiving URIs from VS Code (to Extension):** Similarly, if an extension is listening to an event that includes a URI (say `workspace.onDidOpenTextDocument` which provides a TextDocument with a `.uri` property, or a FileSystemWatcher event), the main thread will serialize the URI into components, send it to the extension host, and the extension host will revive it into a `vscode.Uri` object. The extension gets a real `Uri` instance in the event data. This is done, for example, in the **ExtHost** side of the API implementation: when the main thread notifies the extension host of a new text document, it sends the document’s URI components. The extension host code then does `const uri = URI.revive(uriComponents)` and constructs a `TextDocument` object that includes `uri` as a `vscode.Uri`.
- **Example – URI through Extension API:** The command registration and execution also goes through this mechanism. If an extension command returns a `Uri` and another extension or VS Code retrieves that value, it will have been passed over as a plain object and revived. VS Code even has safeguards: in certain contexts (like context key expressions), if an object with `$mid` is encountered, they convert it to a string via `URI.revive(obj).toString()` ([contextKeyService.ts - microsoft/vscode - GitHub](https://github.com/Microsoft/vscode/blob/master/src/vs/platform/contextkey/browser/contextKeyService.ts#:~:text=Visual%20Studio%20Code,obj%20instanceof)), to avoid leaking complex objects where not needed.

From the extension developer’s point of view, none of this marshalling is visible – they always work with `vscode.Uri` objects. But under the hood, those objects are seamlessly translated to/from the internal `URI` form when communicating with VS Code’s main process.

## Internal Utilities and Abstractions for URIs

VS Code’s codebase includes various **utilities and abstractions** to simplify working with URIs across the product:

- **`resources` Utility Module:** Located in `vs/base/common/resources.ts`, this module provides helper functions to operate on URIs similarly to how one would on file paths. For example, `basename(uri)` returns the last segment of a URI’s path (file name), `dirname(uri)` returns the URI for the parent directory, `extname(uri)` gives the file extension, and `joinPath(baseUri, ...segments)` appends path segments to a base URI ([resources.join & normalize must not change windows drive letter ...](https://git.lance1416.com/Microsoft/vscode/commit/2d9093bcf215189f40eafb2e301db91d0d19a8d5?style=split&whitespace=show-all&show-outdated=#:~:text=resources,export%20function%20joinPath)). These functions take care of trivial but important details (like not duplicating slashes, handling empty authority, preserving case, etc.). By using these helpers, VS Code ensures consistent URI manipulation throughout features like file explorers, editors, and debuggers.
- **`IUriIdentityService`:** VS Code has services to compare and hash URIs for identity. For example, on Windows, paths should be compared case-insensitively. An `IUriIdentityService` can provide comparisons that treat `file:///c:/Foo` and `file:///C:/foo` as the same resource. This helps avoid duplicate entries for what is logically the same file.
- **Working with Non-File URIs:** Many parts of VS Code deal with URIs for things that are not literal files. For instance, VS Code uses URIs with schemes like `untitled:` for new unsaved files, `data:` for data URIs, `vscode-extension:` for extension resources, etc. All of these are still `URI` objects. The text model, for example, is indexed by a URI (so an unsaved file has a URI `untitled:Untitled-1`). The **TextDocument** in the extension API likewise has a `uri: Uri` property for consistency. The URI class and utilities are generic enough that they work with any scheme.
- **Remote and Virtual File Systems:** The abstraction of URIs allows the **Remote Development** features to plug in virtual file systems. A remote file might have a URI like `vscode-remote://ssh-remote+hostname/path/to/file`. The file service knows to route that to an SSH provider. The rest of VS Code largely doesn’t need special cases for it – as long as it consistently uses URIs, the correct provider will handle the resource. When such URIs are passed to extensions, they get a normal `vscode.Uri` which they can inspect (the scheme would be `vscode-remote` in this case) and use in the same way as local URIs.

In summary, **URI management in VS Code** is centralized around the `URI` class and a set of helper modules. File paths are converted into URIs (`URI.file(...)`) early, and thereafter everything is identified by URIs. The core URI module handles parsing, encoding, decoding, and normalization (with special care for Windows). When URIs need to travel across the main renderer and extension host boundary, they are **serialized to plain objects** (`UriComponents`) and then **revived** back into `URI` instances on the other side ([vscode/src/vs/base/common/marshalling.ts at main · microsoft ...](https://github.com/Microsoft/vscode/blob/master/src/vs/base/common/marshalling.ts#:~:text=,any%3E)). The extension API’s `vscode.Uri` is implemented on top of the same logic, so extensions operate with the same URI representation as the VS Code internals. This design ensures that all parts of VS Code – from the core workspace and file services to extensions – speak a common language when referring to resources, making URI handling reliable and consistent.

**Sources:**

1. VS Code `URI.file` implementation and path normalization ([vscode/src/vs/base/common/uri.ts at main - GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/base/common/uri.ts#:~:text=,r.txt%20if)) ([Uri | monaco-editor](https://blutorange.github.io/primefaces-monaco/typedoc/classes/monaco.uri.html#:~:text=Uri%20%7C%20monaco,fsPath%20%29))
2. VS Code `URI.from` and core URI class (VSCode `uri.ts`) ([vscode/src/vs/base/common/uri.ts at main - GitHub](https://github.com/microsoft/vscode/blob/master/src/vs/base/common/uri.ts#:~:text=vscode%2Fsrc%2Fvs%2Fbase%2Fcommon%2Furi.ts%20at%20main%20,path)) ([https://git.lance1416.com/Microsoft/vscode/commit/...](https://git.lance1416.com/Microsoft/vscode/commit/90efeb4f2dc41827b382c8bb5da1c3abfff9459f.patch#:~:text=...%20with%20vscode.Uri%20%28API%29.%20,null%20%3D%20null))
3. VS Code marshalling of URIs and revive logic ([vscode/src/vs/base/common/marshalling.ts at main · microsoft ...](https://github.com/Microsoft/vscode/blob/master/src/vs/base/common/marshalling.ts#:~:text=,any%3E)) ([vscode-uri@3.0.8 - jsDocs.io](https://www.jsdocs.io/package/vscode-uri#:~:text=method%20revive.%20static%20revive%3A%20,UriComponents%29%3A%20URI))
4. VS Code `IFileService` and file system provider usage of URIs ([File watcher: have a `createWatcher(resource: URI)` API for ... - GitHub](https://github.com/microsoft/vscode/issues/126809#:~:text=GitHub%20github,IDisposable%3B%20onDidFilesChange%3A%20Event))
5. VS Code Extension API URI documentation and implementation ([Uri | monaco-editor](https://blutorange.github.io/primefaces-monaco/typedoc/classes/monaco.uri.html#:~:text=Uri%20%7C%20monaco,fsPath%20%29))
