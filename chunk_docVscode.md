#### VSCode and TypeScript and Javascript, a love affair

From Deep Research, from Open AI, from https://chatgpt.com/c/67b36c94-d440-8002-bd0c-2c66025b1d8e

<pre>

# VS Code’s Architecture: Why JavaScript/TypeScript Was the Right Choice

Visual Studio Code’s original architects – notably Erich Gamma and Kai Maetzel (both veterans of Java/Eclipse IDE development) – deliberately chose JavaScript/TypeScript for building VS Code. They found these technologies uniquely suited to implementing a **modular, incremental, layered architecture** with lightweight dependency management, flexible object-oriented patterns, and a powerful extensibility model. Below we explore their reasoning, drawn from interviews, blog posts, and architectural discussions, and how VS Code’s design reflects these principles.

## Modular, Incremental, Layered Architecture

**Layered Core:** VS Code’s core is organized into clear layers (each in a separate folder/module) that build on each other in minimal ways ([Source Code Organization · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Source-Code-Organization#:~:text=,Status%20Bar%2C%20or%20Menu%20Bar)). Key layers include:

- **Base:** Low-level utilities and UI building blocks usable by any layer ([Source Code Organization · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Source-Code-Organization#:~:text=,notebooks%20and%20custom%20editors%20and)).
- **Platform:** Defines common services and a lightweight dependency injection mechanism (no editor- or workbench-specific code here) ([Source Code Organization · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Source-Code-Organization#:~:text=,Status%20Bar%2C%20or%20Menu%20Bar)).
- **Editor:** The Monaco text editor component (standalone and also used inside VS Code) ([Source Code Organization · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Source-Code-Organization#:~:text=include%20,desktop%20app%20that%20stitches%20everything)).
- **Workbench:** The UI shell that hosts the editor and other UI “viewlets” (Explorer, status bar, etc.), using Electron for desktop integration ([Source Code Organization · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Source-Code-Organization#:~:text=include%20,desktop%20app%20that%20stitches%20everything)).
- **Extensions:** Not a layer per se, but _external_ features that plug into VS Code’s API, running in a separate extension host process ([Source Code Organization · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Source-Code-Organization#:~:text=Visual%20Studio%20Code%20consists%20of,folder)).

Each layer has a well-defined responsibility, and higher layers depend only on lower ones. This layered design was influenced by the team’s Eclipse experience – but VS Code’s layers are lighter weight. The layers were delivered incrementally: for example, the team first built the Monaco editor (originally for the browser) and then the “Monaco Workbench” as an internal prototype before VS Code became a full product ([VS Code Day: An event for an editor?](https://code.visualstudio.com/blogs/2023/04/13/vscode-day#:~:text=In%20his%20keynote%20from%20VS,many%20Microsoft%20products%2C%20including%20Azure)) ([VS Code Day: An event for an editor?](https://code.visualstudio.com/blogs/2023/04/13/vscode-day#:~:text=The%20first%20actual%20IDE%20built,Shoutout%20to%20Internet)). This incremental evolution was possible because of the modular separation – e.g. the core editor could be developed and optimized independently as a component, then later embedded in a larger workbench UI.

**Modularity & Swappability:** Within and across layers, VS Code uses a modular approach. Many components are written to **interfaces**, making them interchangeable. In the VS Code codebase, each major feature or service can be isolated and even replaced by a different implementation as long as it fulfills the same interface contract ([VSCode - From Vision to Architecture - DESOSA ](https://2021.desosa.nl/projects/vscode/posts/essay2/#:~:text=the%20modular%20pattern%20comes%20from,another%20layer%2C%20which%20increases%20maintainability)). In fact, some modules (like the `base` utilities or the core `editor`) can run standalone, and any module could be “swapped with [an] different implementation of the same interfaces and still be fully functional” ([VSCode - From Vision to Architecture - DESOSA ](https://2021.desosa.nl/projects/vscode/posts/essay2/#:~:text=the%20modular%20pattern%20comes%20from,another%20layer%2C%20which%20increases%20maintainability)). This is a practical, **flexible take on object-oriented design** that avoids hard-coding assumptions about specific classes. It stands in contrast to the deep class hierarchies common in Java IDEs – instead of inheritance-heavy designs, VS Code favors composition and interface-driven development.

By combining layering and modularity, the VS Code team achieved high maintainability and isolation of concerns. Changes in one layer or component have minimal impact on others, which increases stability and makes testing easier ([VSCode - From Vision to Architecture - DESOSA ](https://2021.desosa.nl/projects/vscode/posts/essay2/#:~:text=implementations%20of%20the%20same%20interfaces,another%20layer%2C%20which%20increases%20maintainability)). Gamma and Maetzel’s background with a large Java IDE taught them the value of this separation. As one analysis noted, this clear layering “helps separate different responsibilities of the code editor... changes in one layer will not affect another, which increases maintainability” ([VSCode - From Vision to Architecture - DESOSA ](https://2021.desosa.nl/projects/vscode/posts/essay2/#:~:text=the%20modular%20pattern%20comes%20from,another%20layer%2C%20which%20increases%20maintainability)). Developers working on VS Code know exactly where to implement a feature, and the architecture naturally guides contributions to the right place ([VSCode - From Vision to Architecture - DESOSA ](https://2021.desosa.nl/projects/vscode/posts/essay2/#:~:text=the%20modular%20pattern%20comes%20from,another%20layer%2C%20which%20increases%20maintainability)).

## Dependency Management via ES Modules and the Filesystem

One of the reasons the creators embraced JavaScript/TypeScript was the simplicity of using the filesystem and module system to manage dependencies. In VS Code, **the file is the unit of modularization** – every source file is an ES module (originally AMD/RequireJS modules, now largely using modern ES module syntax) that explicitly `import`s what it needs. The project structure itself enforces boundaries: for example, the `editor` layer doesn’t import from the `workbench` layer, by convention. This is far simpler than the plugin XML manifests and classpath juggling required in an Eclipse/Java environment.

**Folder-Based Project Structure:** VS Code doesn’t require heavy project configuration files to resolve dependencies. From a user perspective, “the project structure is just files and folders, it’s not... a lot of metafiles... you open a folder, [and VS Code] try[s] to find the project context based on the folder layout” ([
044 AiA Visual Studio Code with Erich Gamma and Chris Dias - Adventures in Angular -

-
Top End Devs
](https://topenddevs.com/podcasts/adventures-in-angular/episodes/044-aia-visual-studio-code-with-erich-gamma-and-chris-dias#:~:text=The%20other%20thing%20I%20would,providing%20intelligence%20accross%20many%20files)). In practice, this means VS Code uses conventions (like recognizing a `package.json` or `tsconfig.json` in a folder) to infer project settings and dependencies. This design stems from the flexibility of JavaScript tooling – Node’s module resolution looks at the filesystem, so VS Code can depend on that rather than a rigid project system. The result is a very **lightweight dependency management** model: if your code or extension is in the right place in the folder structure and exports the right things, VS Code can require/import it. Gamma highlighted that unlike classical IDEs which rely on elaborate project files, VS Code keeps things “very simple” for the developer by leveraging the file system as the source of truth ([
044 AiA Visual Studio Code with Erich Gamma and Chris Dias - Adventures in Angular -

-
Top End Devs
](https://topenddevs.com/podcasts/adventures-in-angular/episodes/044-aia-visual-studio-code-with-erich-gamma-and-chris-dias#:~:text=The%20other%20thing%20I%20would,providing%20intelligence%20accross%20many%20files)).

**ES Modules and Dynamic Loading:** Because VS Code is built with web technologies, it can load components dynamically as needed. Each feature “contribution” in the core is implemented in its own module (often a file named `something.contribution.ts`) which is imported at startup to register that feature. The team intentionally structured the code so that the **workbench core does not statically depend on every feature**. Instead, the core has an internal registry to which modules self-register. According to VS Code’s documentation, “at its core, the workbench does not have direct dependencies to all these contributions. Instead, we use an internal mechanism to contribute these contributions to the workbench” ([Source Code Organization · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Source-Code-Organization#:~:text=VS%20Code%20Workbench%20source%20organisation)). In a nutshell, the core loads each contribution module (by scanning the filesystem or via a compiled import list), and that module’s initialization code uses VS Code’s API to plug its feature into the editor UI or command palette.

This approach was much easier to implement with JavaScript/TypeScript modules than it would have been in Java. In Eclipse, adding a plugin means declaring it in a manifest and loading via OSGi runtime. In VS Code, a new built-in feature is just another TypeScript module in the `contrib` folder that gets bundled – essentially leveraging the **native module loader (Node/Electron)** and file structure. The result is a highly decoupled system: for example, features like Search, Git, or Debug are in separate modules under `workbench/contrib` and the workbench can function with or without them ([Source Code Organization · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Source-Code-Organization#:~:text=VS%20Code%20Workbench%20source%20organisation)) ([Source Code Organization · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Source-Code-Organization#:~:text=,and%20not)). The only “glue” is a lightweight registry that wires them in. JavaScript’s dynamic nature made it straightforward to implement this plugin-like architecture without needing a complex runtime system.

## Object-Oriented Design without Deep Class Hierarchies

Coming from a Java background, VS Code’s creators took a different approach to OOP in TypeScript. They wanted the benefits of object-oriented design (clear interfaces, separation of concerns) **without** the drawbacks of rigid class hierarchies that they’d seen in Eclipse. TypeScript enabled a more **pragmatic OOP style**:

- **Interfaces and Structural Typing:** VS Code defines interfaces for services and components (e.g. an `IEditorService` interface for editor operations). These are not tied to specific classes – any object that satisfies the interface shape can be used. TypeScript uses *structural* typing (not nominal), meaning an object’s compatibility is based on its properties, not its class name ([Source Code Organization · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Source-Code-Organization#:~:text=A%20service%20definition%20is%20two,name%20as%20the%20service%20interface)). This encourages composition over inheritance. For instance, the code might define an interface for a feature, and an implementing class, but it could easily swap in a different implementation later as long as it adheres to the same interface. In Java, by contrast, you’d often have to subclass an existing base class or exactly implement a specific interface to plug into the system. In VS Code, the structural type system makes the connections more flexible.

- **Minimal Inheritance, Maximum Composition:** The VS Code codebase largely avoids long inheritance chains. Instead of subclassing big framework classes, VS Code’s features are often just services or functions registered in the system. Where inheritance is used, it’s usually shallow (for example, one feature might extend a generic base contribution class). More commonly, VS Code uses *composition* patterns – an object might hold references to needed services (injected via constructors) and use them, rather than inherit from a huge context class. Erich Gamma, one of the “Gang of Four” authors of *Design Patterns*, leveraged that knowledge to apply patterns like dependency injection, observer, and command patterns in a lightweight way, suited to TypeScript. His experience from Eclipse taught him what **not** to do – and VS Code’s architecture consciously avoids the parts of Eclipse that were too complex or tightly coupled ([Project Ticino: Microsoft's Erich Gamma on Visual Studio Code past, present, and future • The Register](https://www.theregister.com/2021/01/28/erich_gamma_on_vs_code/#:~:text=background%20in%20software%20patterns%20and,%C2%AE)).

- **Dependency Injection and Services:** Instead of global singletons or massive parent classes, VS Code uses a simple dependency injection mechanism to supply services to components. In the *platform* layer, they defined a small DI container: services are identified by an identifier object and implementations are registered at startup. For example, the interface `IFileService` might be associated with a concrete `FileService` class. VS Code registers it via a helper like `registerSingleton(IFileService, FileService, InstantiationType.Delayed)` – after which any component that declares a dependency on `IFileService` can have it injected ([Source Code Organization · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Source-Code-Organization#:~:text=The%20best%20way%20to%20provide,and%20a%20service%20constructor%20function)). Because TypeScript lacks nominal types, the team introduced a *service identifier* as a workaround: “a service definition is two parts: (1) the interface, and (2) a service identifier – the latter is required because TypeScript doesn't use nominal but structural typing” ([Source Code Organization · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Source-Code-Organization#:~:text=A%20service%20definition%20is%20two,name%20as%20the%20service%20interface)). The service identifier (often created via a `createDecorator`) provides a unique token so the DI container knows exactly what to inject, avoiding confusion that could arise from structural typing (where unrelated interfaces with the same shape would otherwise be indistinguishable to the type system). This design is much simpler than typical Java DI frameworks – it’s essentially a few utility functions in TS, leveraging decorators and metadata. It gives VS Code a decoupled, **service-oriented architecture** without heavyweight infrastructure.

Overall, JavaScript/TypeScript allowed the VS Code team to implement classic OOP *design patterns* in a more **agile and dynamic fashion**. They could introduce patterns as needed rather than bake them into a class hierarchy from the start. For example, rather than a monolithic “Editor” class with dozens of methods, VS Code has an Editor component that **composes many services and contributions** (rendering, configuration, undo/redo, etc.), each behind its own interface. This keeps each part of the system smaller and easier to refactor.

## Extensibility through Services, Registries, and Contributions

Extensibility is at the heart of VS Code’s architecture. The creators designed the editor to be expanded both internally and by third-party extensions, taking inspiration from Eclipse’s plugin system but simplifying it greatly for the web/Node environment.

**Internal Contributions:** Within the core code, many features are implemented as **contributions** that are added via a registry. The workbench layer defines extension points for things like viewlets, editors, panel entries, etc., and modules in `vs/workbench/contrib/...` implement those. Crucially, the workbench doesn’t need to know about every feature – it just knows how to load contributions. As the VS Code wiki notes, the workbench core is kept “as minimal as possible,” and features like search, git, or debug are **plugged in** via an internal contribution mechanism ([Source Code Organization · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Source-Code-Organization#:~:text=The%20VS%20Code%20workbench%20%28,these%20contributions%20to%20the%20workbench)). Each contribution module typically: registers any new services it needs, contributes UI components or commands via the extension registries, and then integrates with the workbench through well-defined interfaces. For example, the search contribution registers a Search pane in the sidebar and commands in the Command Palette, all through centralized registries. This is conceptually similar to Eclipse’s extension points but implemented with simple JavaScript objects and function calls rather than XML. It’s **lightweight and dynamic** – adding a new built-in feature is as easy as dropping in a new module and listing it in the product’s startup imports.

Internally, VS Code uses numerous registries (or “registries by convention”). There are registries for commands, for editor contributions, for languages, etc. When a contribution module runs, it calls an API (like `registerCommand` or `registerEditorContribution`) to inform VS Code of new capabilities. These go into in-memory registries that the workbench and editor query when needed (e.g., to populate the command palette or to apply an editor decoration). Thanks to JavaScript’s flexibility, these registrations are just function calls at startup. In a language like Java, you might need to use reflection or service loaders; in VS Code it’s straightforward.

A concrete example of this is how the **editor features** (like code folding, bracket matching, link detection) are implemented as contributions. They live under `vs/editor/contrib` and each defines a small class or function that hooks into the editor lifecycle. The editor has a registry for such contributions and activates them as needed. This modular approach means even core editor functionality is extensible and optional – one can create a bare-bones Monaco editor by omitting certain contrib modules ([Source Code Organization · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Source-Code-Organization#:~:text=code%20without%20which%20an%20editor,that%20ship%20in%20VS%20Code)). It’s an architecture that **treats even first-party features like plugins**, giving tremendous flexibility.

**Extension API for Third-Party Plugins:** Beyond the internal architecture, Gamma’s team built a robust extension API (in TypeScript) so developers can add their own features (language support, debuggers, linters, etc.) without modifying the core. This API uses a **service-based model** as well: extensions interact with VS Code through a `vscode` module (which is actually a façade that sends IPC messages to the core). The use of TypeScript made it easy to define this API as an ambient d.ts file that extension authors use for IntelliSense ([GOTO Conferences Talk: The Journey of a Large Scale Application Built Using JavaScript - TypeScript, Node, Electron & 100 OSS Components at Microsoft from GOTO Conferences | Class Central](https://www.classcentral.com/course/youtube-building-an-app-using-js-typescript-node-electron-100-oss-components-erich-gamma-goto-2016-194398#:~:text=extension%20system,Provider%20Pattern%20for%20API%20design)). Notably, VS Code’s extension host communicates with the editor via a JSON-based IPC protocol, following the “Language Server Protocol” style that decouples the UI from language tooling ([
044 AiA Visual Studio Code with Erich Gamma and Chris Dias - Adventures in Angular -

-
Top End Devs
](https://topenddevs.com/podcasts/adventures-in-angular/episodes/044-aia-visual-studio-code-with-erich-gamma-and-chris-dias#:~:text=the%20scenes%20,to%20give%20us%20its%20IntelliSense)). This multi-process design (enabled by Node/Electron) ensures extensions run isolated from the UI, improving stability ([
044 AiA Visual Studio Code with Erich Gamma and Chris Dias - Adventures in Angular -

-
Top End Devs
](https://topenddevs.com/podcasts/adventures-in-angular/episodes/044-aia-visual-studio-code-with-erich-gamma-and-chris-dias#:~:text=the%20scenes%20,That%27s%20another%20interesting)).

The creators often emphasize how **essential TypeScript was for building the extension ecosystem**. Many extensions are themselves written in TypeScript, and VS Code’s reliance on TypeScript provided the team with the confidence to open up APIs and iterate quickly. Because of static typing, both core developers and extension authors get immediate feedback if an API contract is broken or used incorrectly – a huge boon compared to purely dynamic JavaScript.

## TypeScript’s Structural Typing: Enabling Flexibility and Refactoring

**Why JavaScript alone wasn’t enough:** Early in the “Monaco” project (the browser editor that led to VS Code), the team started with JavaScript but soon hit scalability issues as the codebase grew. Having come from Java, Gamma and team wanted a way to keep code maintainable at scale. They adopted TypeScript around 2012-2013 and ultimately rewrote the entire VS Code/Monaco codebase in TypeScript ([Project Ticino: Microsoft's Erich Gamma on Visual Studio Code past, present, and future • The Register](https://www.theregister.com/2021/01/28/erich_gamma_on_vs_code/#:~:text=Gamma%20gave%20a%20shout,written%20in%20TypeScript%2C%20said%20Gamma)). The static typing and tooling helped manage a large codebase, but equally important was TypeScript’s **structural type system**, which fit their architecture philosophy.

Erich Gamma himself credits TypeScript for VS Code’s success: *“This 10-year journey wouldn’t have been possible unless we had TypeScript as the tool that helped us to keep our code flexible so we can restructure it,”* he said ([Project Ticino: Microsoft's Erich Gamma on Visual Studio Code past, present, and future • The Register](https://www.theregister.com/2021/01/28/erich_gamma_on_vs_code/#:~:text=Gamma%20gave%20a%20shout,written%20in%20TypeScript%2C%20said%20Gamma)). This “flexibility to restructure” points to how TypeScript’s type system supports large-scale refactoring. Unlike Java, you don’t need to rigidly declare class hierarchies up front – you can refactor and reshape your code, and as long as the interfaces still match up (structurally), things will continue to work. The compiler catches mismatches, making large refactors far less risky than in pure JavaScript, yet it doesn’t impose the heavy ceremony of Java. In essence, TypeScript gave the VS Code team the **best of both worlds**: the agility of a scripting language with the safety nets of static typing.

**Structural Typing in Practice:** Structural typing means any object that satisfies an interface is considered of that type, without an explicit `implements` declaration. For VS Code, this was beneficial in designing the extension APIs and internal plugin points. They could define a contract (say, what a language service should provide) and different implementations (in different extensions or built-in features) could be accepted as long as they had the right shape. This reduces coupling – e.g., the core doesn’t need to know the exact class of a feature, just that it has certain methods. It also simplified testing and mocking, since test doubles only need to mimic the interface shape. In a nominal system like Java, you might have to create subclass hierarchies or use reflection to achieve similar flexibility.

However, the team also had to balance structural typing with clarity. That’s why the service identification pattern was introduced – to avoid accidental mix-ups when two distinct services have similar shape. By using an explicit identifier (often a `Symbol` or unique object) for each service, they ensured that the DI system remains robust ([Source Code Organization · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Source-Code-Organization#:~:text=A%20service%20definition%20is%20two,name%20as%20the%20service%20interface)). This is a small price to pay (essentially one line per service) for the huge gains in flexibility.

**Support for New Patterns:** TypeScript also enabled new architectural patterns in VS Code that would be cumbersome in Java. One example is the **provider pattern** used extensively in the extension API (documented in the GOTO 2016 talk ([GOTO Conferences Talk: The Journey of a Large Scale Application Built Using JavaScript - TypeScript, Node, Electron & 100 OSS Components at Microsoft from GOTO Conferences | Class Central](https://www.classcentral.com/course/youtube-building-an-app-using-js-typescript-node-electron-100-oss-components-erich-gamma-goto-2016-194398#:~:text=adoption%20of%20Electron%2C%20the%20benefits,Provider%20Pattern%20for%20API%20design))). For instance, VS Code doesn’t hard-code how to find references or perform code completion. Instead, it defines an interface (shape) for a “ReferenceProvider” or “CompletionItemProvider”. Extensions (or built-in language plugins) register providers for given file types. Because of structural typing, as long as an object has the required provideX function, VS Code can use it – whether it’s implemented in a class or just an object literal. This would be awkward in Java (where you’d likely need an abstract base class or have to register instances via reflection). In TypeScript, it’s natural and lightweight, fitting perfectly with VS Code’s **service+contribution architecture**.

Finally, TypeScript’s ecosystem (with `.d.ts` type definition files) allowed VS Code to **leverage JavaScript libraries safely**. The team could incorporate 100+ open-source JS components ([GOTO Conferences Talk: The Journey of a Large Scale Application Built Using JavaScript - TypeScript, Node, Electron & 100 OSS Components at Microsoft from GOTO Conferences | Class Central](https://www.classcentral.com/course/youtube-building-an-app-using-js-typescript-node-electron-100-oss-components-erich-gamma-goto-2016-194398#:~:text=51,Provider%20Pattern%20for%20API%20design)) (for example, using existing Node modules for git, JSON parsing, etc.) and still have type safety via definitions. This meant they didn’t have to reinvent the wheel for core functionality, focusing instead on integrating those components in a structured way. In Gamma’s words, TypeScript “adds strong typing to JavaScript,” and that was essential to keep the large VS Code project from collapsing under its own complexity ([Project Ticino: Microsoft's Erich Gamma on Visual Studio Code past, present, and future • The Register](https://www.theregister.com/2021/01/28/erich_gamma_on_vs_code/#:~:text=Gamma%20gave%20a%20shout,written%20in%20TypeScript%2C%20said%20Gamma)). It enabled a small team to maintain a codebase on par with large traditional IDEs, by making sure modules could evolve and integrate cleanly.

## Conclusion

The creators of VS Code harnessed JavaScript and TypeScript to build an editor that is modular, extensible, and highly performant – a design influenced by their past experiences with Java IDEs, but reimagined for the modern web stack. **JavaScript/TypeScript proved uniquely suited to their goals**: the use of TypeScript’s structural type system and modules allowed a clean layered architecture, fine-grained dependencies, and an “plugin everything” mentality, without the weight of Java’s class hierarchies or complex build systems. The result is that VS Code’s architecture is *incremental* (developed and delivered in pieces), *layered* (each part with clear responsibility), and *open* to extension at every level. As Erich Gamma noted, not using an over-engineered framework or rigid patterns gave them full control to optimize and innovate ([Project Ticino: Microsoft's Erich Gamma on Visual Studio Code past, present, and future • The Register](https://www.theregister.com/2021/01/28/erich_gamma_on_vs_code/#:~:text=,control%20of%20our%20own%20destiny)) – and TypeScript was the key that kept this engine running smoothly.

VS Code stands as a testament to how a small, well-architected core in TypeScript, combined with a rich ecosystem of contributions and extensions, can scale to a project with millions of users and thousands of extensions, all while remaining approachable and **“simple” in feel (just files and folders!) for developers ([
044 AiA Visual Studio Code with Erich Gamma and Chris Dias - Adventures in Angular -

-
Top End Devs
](https://topenddevs.com/podcasts/adventures-in-angular/episodes/044-aia-visual-studio-code-with-erich-gamma-and-chris-dias#:~:text=The%20other%20thing%20I%20would,providing%20intelligence%20accross%20many%20files))**. The choices made by its creators show a deep understanding of both the strengths of web technologies and the lessons learned from earlier IDEs – resulting in a developer tool that many consider the best of both worlds.

**Sources:**

- Gamma, E. & others – *Visual Studio Code Architecture Discussions* (Layered core and services) ([Source Code Organization · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Source-Code-Organization#:~:text=Visual%20Studio%20Code%20consists%20of,folder)) ([Source Code Organization · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Source-Code-Organization#:~:text=A%20service%20definition%20is%20two,name%20as%20the%20service%20interface))
- VS Code Wiki – “Source Code Organization” (Layers, dependency injection, contributions) ([Source Code Organization · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Source-Code-Organization#:~:text=VS%20Code%20Workbench%20source%20organisation)) ([Source Code Organization · microsoft/vscode Wiki · GitHub](https://github.com/microsoft/vscode/wiki/Source-Code-Organization#:~:text=The%20best%20way%20to%20provide,and%20a%20service%20constructor%20function))
- DESOSA Project – *VSCode: From Vision to Architecture* (Modular design and interfaces) ([VSCode - From Vision to Architecture - DESOSA ](https://2021.desosa.nl/projects/vscode/posts/essay2/#:~:text=Let%E2%80%99s%20start%20by%20taking%20a,which%20hosts%20the%20Monaco)) ([VSCode - From Vision to Architecture - DESOSA ](https://2021.desosa.nl/projects/vscode/posts/essay2/#:~:text=the%20modular%20pattern%20comes%20from,another%20layer%2C%20which%20increases%20maintainability))
- Hanselman, S. – *Hanselminutes Podcast*: Erich Gamma & Kai Maetzel interview (project structure, philosophy) ([
044 AiA Visual Studio Code with Erich Gamma and Chris Dias - Adventures in Angular -

-
Top End Devs
](https://topenddevs.com/podcasts/adventures-in-angular/episodes/044-aia-visual-studio-code-with-erich-gamma-and-chris-dias#:~:text=The%20other%20thing%20I%20would,providing%20intelligence%20accross%20many%20files)) ([
044 AiA Visual Studio Code with Erich Gamma and Chris Dias - Adventures in Angular -

-
Top End Devs
](https://topenddevs.com/podcasts/adventures-in-angular/episodes/044-aia-visual-studio-code-with-erich-gamma-and-chris-dias#:~:text=the%20scenes%20,That%27s%20another%20interesting))
- The Register – *Interview with Erich Gamma* (TypeScript enabling flexibility & refactoring) ([Project Ticino: Microsoft's Erich Gamma on Visual Studio Code past, present, and future • The Register](https://www.theregister.com/2021/01/28/erich_gamma_on_vs_code/#:~:text=Gamma%20gave%20a%20shout,written%20in%20TypeScript%2C%20said%20Gamma))
- VS Code Blog – *VS Code Day Keynote Highlights* (History of Monaco editor to VS Code) ([VS Code Day: An event for an editor?](https://code.visualstudio.com/blogs/2023/04/13/vscode-day#:~:text=In%20his%20keynote%20from%20VS,many%20Microsoft%20products%2C%20including%20Azure)) ([VS Code Day: An event for an editor?](https://code.visualstudio.com/blogs/2023/04/13/vscode-day#:~:text=that%20vision%20was%20the%20Monaco,many%20Microsoft%20products%2C%20including%20Azure))
- GOTO 2016 Talk – Erich Gamma on building VS Code (Insights on using 100+ OSS components, extension system) ([GOTO Conferences Talk: The Journey of a Large Scale Application Built Using JavaScript - TypeScript, Node, Electron & 100 OSS Components at Microsoft from GOTO Conferences | Class Central](https://www.classcentral.com/course/youtube-building-an-app-using-js-typescript-node-electron-100-oss-components-erich-gamma-goto-2016-194398#:~:text=51,Provider%20Pattern%20for%20API%20design))
</pre>
